<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[My Blog]]></title>
  <link href="http://pengfx.github.io/atom.xml" rel="self"/>
  <link href="http://pengfx.github.io/"/>
  <updated>2013-05-06T10:43:35+08:00</updated>
  <id>http://pengfx.github.io/</id>
  <author>
    <name><![CDATA[Peng Feixiang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[draft-mccann-dmm-flatarch-00]]></title>
    <link href="http://pengfx.github.io/blog/2013/05/06/draft-mccann-dmm-flatarch-00/"/>
    <updated>2013-05-06T10:59:00+08:00</updated>
    <id>http://pengfx.github.io/blog/2013/05/06/draft-mccann-dmm-flatarch-00</id>
    <content type="html"><![CDATA[<h1>Authentication and Mobility Management in a Flat Architecture</h1>

<h3><a href="http://tools.ietf.org/html/draft-mccann-dmm-flatarch-00">draft-mccann-dmm-flatarch-00</a></h3>

<p>从运营商角度看待移动性管理，包含部署、身份认证等，略之</p>

<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[draft-ma-dmm-romip-00]]></title>
    <link href="http://pengfx.github.io/blog/2013/05/06/draft-ma-dmm-romip-00/"/>
    <updated>2013-05-06T10:55:00+08:00</updated>
    <id>http://pengfx.github.io/blog/2013/05/06/draft-ma-dmm-romip-00</id>
    <content type="html"><![CDATA[<h1>A Route Optimization solution support for Distributed Mobility Management</h1>

<h3><a href="http://tools.ietf.org/id/draft-ma-dmm-romip-00.txt">draft-ma-dmm-romip-00</a></h3>

<p>The first elements that provide IP connectivity to a set of MNs are also the mobility managers for those MNs.</p>

<ul>
<li>移动节点不参与任何与移动相关的信令交互。移动锚和接入路由器以及AAA代表主机负责管理IP移动性。</li>
<li>The Home Address (HoA 切换前MAAR分配的地址) and Care-of address (CoA 切换后MAAR分配的地址).</li>
<li>移动节点可以直接向通信节点发送数据包而不需要通过家乡移动锚。</li>
</ul>


<hr />

<h2>1.  Introduction</h2>

<ol>
<li>MIPv6 和 PMIPv6的缺点</li>
<li>在论文“<a href="http://eprints.networks.imdea.org/13/1/giust_mmfn2011.pdf">一个基于网络的分布式移动管理的局部性移动解决方案</a>”中，作者表述了两种方法：一个是完全分布式的方法，另一个是部分分布式的方法。第一个方法的主要问题是，如何在第一次连接到网络的时候和随后的切换之间区分移动锚和接入路由器。</li>
<li>这篇文档描述了移动锚和接入路由器以及AAA协议代表主机对IP移动性的支持。这个解决方案能解决两方面的问题，它不仅使得移动实体能在第一次接入网络时和随后的切换之间进行区分，而且能减少家乡移动锚的重担。移动节点能直接向通信节点转发数据包。数据包的发送不需要通过家乡移动锚。 这篇文档时严格遵照这两方面进行展开。</li>
<li>所遵循的两个原则:移动节点的移动对通信节点来说是透明的；移动节点不参与任何与移动相关的信令交互。</li>
</ol>


<h2>2.  Terminology</h2>

<ul>
<li>MAAR (Mobility anchor and Access Router)</li>
<li>AAA (Authentication, Authorization and Accounting )</li>
<li>DBU/DBA (Distributed BU/BA)</li>
<li>sDBU/sDBA.  The MAAR attached by the MN currently to sends a sDBU message to the MAAR attached by MN before the MN&#8217;s movement.  After that, the MAAR attached by MN currently receives a sDBA message including the address of CN&#8217;s MAAR which the CN is currently attached to.  After that, the MAAR attached by the MN currently updates its internal binding list.</li>
<li>dDBU/dDBA.  The MAAR attached by the MN currently sends a dDBU message to the MAAR attached by CN for refreshing the internal binding list of the CN&#8217;s MAAR which the CN is currently attached to. After receiving the dDBU message, the CN&#8217;s MAAR replies a dDBA message to the MN&#8217;s MAAR.</li>
</ul>


<h2>3.  Operation</h2>

<pre><code>+----------+  +----------+ +-------+  +-------+   +-------+     +-----+
|The user A|  |The user B| |A_MAAR2|  |B_MAAR2|   |A_MAAR3|     | AAA |
+----------+  +----------+ +-------+  +-------+   +-------+     +-----+
     |             |           |          |           |             |
     |--------------1.RS(A_HoA1,B_HoA1)--------------&gt;|             |
     |             |           |          |           |-2.request--&gt;|
     |             |           |          |           |&lt;-3.response-|
     |&lt;-------------------4.RA(A_HoA3) ---------------|             |
     |             |           |          |           |             |
     |             |           |&lt;-------5.sDBU -------|             |
     |             |           |------6. sDBA -------&gt;|             |
     |             |           |          |&lt;-7.dDBU --|             |
     |             |           |          |--8.dDBA -&gt;|             |
     |             |           |          |           |             |


                 Figure 1:Signaling of MN handover



  ________                          ________
 |The user|                        |The user|
 |   B    |----------move---------&gt;|   B    |
 |________|                        |________|
                                      #  *
                                      #  *
                                      #  *
  +-------+                       +-------+
  |       |                       |       |
  |B_MAAR1|                       |B_MAAR2|
  |       |                     / |       |
  +-------+                    /  +-------+
                              /  #  /| * |
                             /  #  / | * |
                            /  #  /  | * |
                           /  #  /   | * |
                          /  #  /    | * |
                         /  #  /     | * |
+-------+        +-------+ #  /    +-------+
|       |        |       |   /     |       |
|A_MAAR1|        |A_MAAR2|  /      |A_MAAR3|
|       |        |       |         |       |
+-------+        +-------+         +-------+
                    #                   *
                    #                   *
                    #                   *
 ________         ________             ________
|The user|       |The user|           |The user|
|   A    |-move-&gt;|   A    |---move---&gt;|   A    |
|________|       |________|           |________|


             Figure 2:The transmission of data packets
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[draft-ma-dmm-armip-00]]></title>
    <link href="http://pengfx.github.io/blog/2013/05/06/draft-ma-dmm-armip-00/"/>
    <updated>2013-05-06T10:50:00+08:00</updated>
    <id>http://pengfx.github.io/blog/2013/05/06/draft-ma-dmm-armip-00</id>
    <content type="html"><![CDATA[<h1>An AR-level solution support for Distributed Mobility Management</h1>

<h3><a href="https://tools.ietf.org/html/draft-ma-dmm-armip-00">draft-ma-dmm-armip-00</a></h3>

<hr />

<h2>1.  Introduction</h2>

<p>这篇文档以主机的方式描述了MAAR和AAA对IP移动性管理的支持。这能够解决移动实体对第一次连接到网络和随后切换之间的区分这一问题。本文件严格遵守两个原则。第一个是，MN（移动节点）的移动对CN（核心网络）是透明的。另一个是MN（移动节点）不参与任何和移动性相关的信令传输。</p>

<h2>2.  Terminology</h2>

<ul>
<li>MAAR(Mobility anchor and Access Router)</li>
<li>AMAAR (Accessing MAAR).指当前MN连接到的MAAR.每个ALMN必须为当前注册过的移动节点建立并维护两个绑定的列表。一个是内部绑定列表，另一个是外部绑定列表。每一个AMAAR都为新用户配置IPv6地址。因此AMAAR代表每一个移动节点执行移动性管理。每个AMAAR负责检测移动节点的运动和接入链路，并且用于绑定注册的初始化。</li>
<li>FMAAR (Forwarding MAAR).指被MN以前访问过的MAAR，仍有active flow。MN可以具有一个或多个FMAAR。</li>
<li>AAA (Authentication, Authorization and Accounting). AAA服务器记录用户的静态和动态信息，而动态信息包括该MN当前注册的MAAR的地址信息。</li>
<li><p>DBU/DBA (Distributed BU/BA).一个MAAR发送DBU/DBA消息给另一个MAAR来建立相应的绑定列表。在本文中，有两种DBU/DBA信息。一个是pDBU/pDBA消息，另一个是的fDBU/ fDBA消息。</p></li>
<li><p>pDBU/pDBA.pDBU消息是通过移动节点的AMAAR发送给PMAAR,目的是在移动节点的AMAAR和PMAAR之间建立绑定。这个消息包括了AMAAR的地址。收到pDBU消息后，PMAAR给AMAAR发送一个pDBA消息进行答复，此消息包括FMAAR的地址和由FMAAR分配的MN的地址。fDBU/fDBA.fDBA消息由移动节点的AMAAR发送给FMAAR（不包括PMAAR），目的是在移动节点的AMAAR和FMAAR(不包括PMAAR)之间建立绑定。这个消息包括AMAAR的地址。收到fDBU消息后，FMAAR会给AMAAR发送一个fDBA消息进行答复。</p></li>
</ul>


<h2>3.  MAAR Operation</h2>

<h4>关键操作</h4>

<ul>
<li>AMAAR MUST send diameter request message to the AAA after detecting the MN&#8217;s movement to the access link.AAA能够区分MN是第一次连接，还是切换后的连接。</li>
<li>MAAR 维护两个绑定列表，内部绑定列表和外部的绑定列表。内部列表里绑定FMAAR分配的MN地址和MN的FMAAR的地址；内部绑定列表里绑定AMAAR分配的MN的地址和FMAAR分配的此MN的地址。</li>
<li>每个FMAAR必须为每个之前注册过的MN维护一个绑定列表。这张列表存储了由FMAAR分配的MN的地址的绑定和此MN的AMAAR的地址。</li>
<li>AMAAR和PMAAR建立双向隧道转发属于MN的所有数据流量。（地址绑定——AMAAR从AAA那获取PMAAR地址，AMAAR向PMAAR发送pDBU）</li>
</ul>


<h2>4.  Description of the solution</h2>

<p>分布式移动管理方法的目的是克服传统的集中式移动管理的限制，通过使移动锚点更接近MN.遵循这一理念，我们建议，中央锚移动到网络的边缘，被部署在所述移动节点的接入路由器。也就是说，提供MN IP连通性的第一个元素也就是这些MN的移动管理者。</p>

<pre><code>    +-----+     +------+   +------+       +------+          +----+
    |  MN |     | MAAR1|   | MAAR2|       | MAAR3|          | AAA|
    +-----+     +------+   +------+       +------+          +----+
       |           |           |             |                 |
       |-----------1.RS(HoA1,HoA2)----------&gt;|                 |
       |           |           |             |----2.request---&gt;|
       |           |           |             |&lt;---3.response---|
       |&lt;----------4.RA(HoA3)--------------- |                 |
       |           |           |             |                 |
       |           |           |&lt;--5.pDBU ---|                 |
       |           |           |--6. pDBA --&gt;|                 |
       |           |&lt;--------7.fDBU ---------|                 |
       |           |---------8.fDBA --------&gt;|                 |
       |           |                         |                 |



                 Figure 1:Signaling of MN handover
</code></pre>

<ol>
<li>MN从MAAR1，MAAR2 切换到MAAR3，MN发送一个包含HoA1和HoA2的消息给MAAR3。</li>
<li>MAAR3发送diameter请求信息给AAA</li>
<li>AAA有MAAR2的地址信息。AAA发送包含MAAR2的diameter答复信息，然后AAA更新包括MAAR3地址信息在内的MN的动态信息。</li>
<li>MAAR3分配给MN另一个IPv6地址（HoA3）。同时，MAAR3建立并维护存储HoA1和HoA3，HoA2和HoA3绑定的外部绑定列表。</li>
<li>与此同时，MAAR3发送包含MAAR3地址的pDBU信息给MAAR2.</li>
<li>现在MAAR2有两个绑定列表。一个是内部绑定列表，另一个是外部绑定列表。第一个存储MAAR1的地址和HoA1。第二个存储HoA1和HoA1的绑定。在收到pDBU信息之后，MAAR2发送包括内部绑定列表、HoA2和MAAR2的地址在内的pDBA信息。之后，MAAR2用一个存储了HoA2和MAAR3地址的绑定列表替换这两个绑定列表。</li>
<li>在收到pDBA信息后，MAAR3建立并维护这个存储了HoA1和MAAR1的地址绑定、HoA2和MAAR2的地址绑定的内部绑定列表。MAAR3发送包含MAAR3地址的fDBU信息给MAAR1。</li>
<li>在收到fDBU信息后，MAAR1回复一个fDBA信息，并且更新之前存储HoA1和MAAR2的地址的绑定列表。这个列表现在存储了HoA1和MAAR3的地址。</li>
</ol>


<h2>5.  Forwarding Considerations</h2>

<p>在收到有MN发送的数据包后，AMAAR将会检查数据包的源地址。如果这个地址是由AMAAR分配的，AMAAR就会根据包的目的地址将包转发给CN。如果地址不是由AMAAR分配的，AMAAR就会根据源地址搜索内部绑定列表，然后找到相应的FMAAR的地址。然后，AMAAR封装这些包到相应的FMAAR。</p>

<pre><code>    _______         _______          _______
   |       |       |       |        |       |
   |  CN1  |       |  CN2  |        |  CN3  |
   |_______|       |_______|        |_______|
       '               *  Flow#2         .
Flow#1 '               *                 | Flow#3
       '  ..... '''''''*''''''''''''..... .
     ..'''             *                 '''..
   .'  '            IP * network         .   '.
   :   '               *                 |    :
    '..'           +-------+             . ..'
       '''.......  |       |    ........'''
       '           | MAAR2 |\            .
       '           |       | \           |
       '           |       |* \          .
       '           +-------+\* \         |
 +-------+                   \* \ + ------+
 |       |                    \*  |       |
 | MAAR1 |------------------------| MAAR3 |
 |       |''''''''''''''''''''''''|       |
 |       |------------------------|       |
 +-------+                        +-------+
                                     ' * |
                             Flow#1  ' * . Flow#3
                                     ' * |
   +-----+                   Flow#2 +-----+
   | MN  | ----------move---------&gt; | MN  |
   +-----+                          +-----+


              Figure 2:The transmission of data packets
</code></pre>

<h2>6.  Message Formats</h2>

<p>略</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[draft-luo-dmm-with-mip-and-pmip-00]]></title>
    <link href="http://pengfx.github.io/blog/2013/05/06/draft-luo-dmm-with-mip-and-pmip-00/"/>
    <updated>2013-05-06T10:50:00+08:00</updated>
    <id>http://pengfx.github.io/blog/2013/05/06/draft-luo-dmm-with-mip-and-pmip-00</id>
    <content type="html"><![CDATA[<h1>Distributed Mobility Management Approach with Mobile IP and Proxy Mobile IP</h1>

<h3><a href="http://tools.ietf.org/html/draft-luo-dmm-with-mip-and-pmip-00">draft-luo-dmm-with-mip-and-pmip-00</a></h3>

<pre><code>本文提出了分布式移动管理体系结构的概念以及该结构的一些主要处理方法。
这些处理方法可以兼容现有的移动IP和代理移动IP协议。
</code></pre>

<hr />

<h2>Introduction</h2>

<p>集中式移动锚定有一些诸如单点故障、非最优路径路由等缺点。这些缺点在<a href="http://tools.ietf.org/html/draft-liu-mext-distributed-mobile-ip-00">I-D.liu-mext-distributed-mobile-ip</a>中讨论过了。</p>

<p>本文提出了分布式移动管理体系结构的概念以及该结构的一些主要处理方法。这些处理方法可以兼容现有的移动IP和代理移动IP协议。</p>

<p>本文只是一个初稿，并不为了解决<a href="http://tools.ietf.org/html/draft-liu-mext-distributed-mobile-ip-00">I-D.liu-mext-distributed-mobile-ip</a>中所提出的所有问题。</p>

<h2>Terminology</h2>

<p>移动路由(MR)，这是一个逻辑功能，用于拦截从移动节点和HoA发送/接收的数据包并转发数据包，根据位置信息执行分布式路由选择。</p>

<p>主地址分配(HAA)，这是一个逻辑功能，用于向一个移动节点分配主网络前缀或主地址。</p>

<p>位置管理(LM)，这是一个逻辑功能，用于管理并跟踪移动节点位置信息，其中包括MN的HoA与MN路由地址(或另一网络元素，它知道如何对MN的数据包进行转发)的映射。</p>

<h2>Solution Overview</h2>

<p>本方案将集中式锚点分解为下列逻辑功能，来允许使用更灵活的设计来实现DMM：</p>

<ul>
<li><p>主地址分配功能</p></li>
<li><p>移动路由功能</p></li>
<li><p>位置管理功能</p>

<pre><code>          One Administrative Domain

  (     LM1/HAA1    )(  LM2/HAA2 )(   LM3   HAA3  )
  (                 )(           )(               )
  (                 )(           )(               )
  (  MR11     MR12  )(     MR2   )( MR31    MR32  )
      +                               +
      |     Local        Local        |     Local
      |    Network1     Network2      |    Network3
      +                               +
     MN1                             MN2

     Figure 1.  An example of DMM deployment
</code></pre></li>
</ul>


<p>本文中假设所有本地网络均属于同一个管理域。</p>

<p>MN最初连接的本地网络被称为它的Home Local Network。HAA功能是负责移动节点的IP地址\分配（例如HoA\HNP）。在移动过程中，移动节点可以离开它的Home Local Network进入另一个本地网络——Visited Local Network。</p>

<pre><code>+-------------------------------------+  +--------------------------+
|  +---------+         +---------+    |  |        +---------+       |
|  |   HAA   |         |   LM    +&lt;---+--+-------&gt;+   LM    |       |
|  +---+-----+         +----+----+    |  |        +----+----+       |
|      ;                   /|\        |  |            /|\           |
|     /|\                   |         |  |             |            |
|      |                   \|/        |  |            \|/           |
|      |               +----+----+    |  |        +----+----+       |
|      +-------------&gt; |   MR    +&lt;---+--+-------&gt;+   MR    |       |
|                      +--+---+--+    |  |        +--+---+--+       |
|                        /|\ /|\      |  |          /|\ /|\         |
|                         |   |       |  |           |   |          |
|                         |___|       |  |           |___|          |
|                                     |  |                          |
| Home Local Network                  |  | Visited Local Network    |
+-------------------------------------+  +--------------------------+

 Figure 2.  Architecture
</code></pre>

<p>HAA、LM和MR之间需要接口，它们被描述如下：</p>

<pre><code>   a.  HAA和MR之间的接口支持当在MN依附MR时，IP前缀或地址的分配。

   b.  LM和MR之间的接口支持MN路由位置管理，以及为MN设置最优路由。

   c.  MR和MR之间的接口支持在控制平面MN从原MR（pMR）切换到新的MR（nMR），并支持在数据平面以分布式的方式分发MN与CN间的流量
</code></pre>

<p>一个管理域可能存在大量的移动节点，LM可能需要保存大量的信息，LM可以以分布式数据库的形式来部署。</p>

<h2>Overview of the Distributed Mobility Management Approaches</h2>

<h4>Initial Attachment</h4>

<h4>Dynamic Mobility Management</h4>

<ol>
<li>pMR和nMR的HoA\HNP对于移动节点是可用</li>
<li>nMR下新发起的会话，优选使用新的HoA\HNP作为源IP</li>
<li>切换前发起的旧会话仍然可以使用旧的HoA\HNP作为源IP。</li>
</ol>


<p>上述策略基于以下前提：</p>

<ol>
<li><strong>移动节点应该可以管理多个HoAs\HNP</strong>。</li>
<li><strong>MN可以在MN上的应用请求IP地址绑定时决定返回哪一个HoA</strong>。</li>
</ol>


<h4>Distributed Routing</h4>

<pre><code>+-----+      +-------+     +-------+    +--------+     +-----+
| MN2 |      |  MR31 |     |  LM   |    |  MR11  |     | MN1 |
+-----+      +-------+     +-------+    +--------+     +-----+
   |             |            |             |             |
   |1.IP Traffic |            |             |             |
   |===========&gt; | 2. Query   |             |             |
   |             |----------&gt; |             |             |
   |             | 3. Rsp     |             |             |
   |             |&lt;------ ----|             |             |
   |   +------------------+   |             |             |
   |   | 4.Record Location|   |             |             |
   |   |   of MN1 Locally |   |             |             |
   |   +------------------+   |             |             |
   |             |  5. Distributed Routing  |             |
   |             |========================&gt; |             |
   |             |            |             |6.IP Traffic |
   |             |            |             |===========&gt; |
   |             |            |             |             |

    Figure 3.  Optimized routing based on location query



+-----+      +-------+     +-------+    +--------+   +--------+   +-----+
| MN2 |      |  MR31 |     |  LM1  |    |  MR12  |   |  MR11  |   | MN1 |
+-----+      +-------+     +-------+    +--------+   +--------+   +-----+
   |             |            |             |            |           |
   |1.IP Traffic |            |             |            |           |
   |============&gt;|            |             |            |           |
   |    +-------------------+ |             |            |           |
   |    |2.Don't have MN1's | |             |            |           |
   |    |  Routing Location | |             |            |           |
   |    +-------------------+ |             |            |           |
   |             | 3. Regular IPv6 Routing  |            |           |
   |             |========================&gt; |            |           |
   |             |            |   4. Query  |            |           |
   |             |            |&lt;------------|            |           |
   |             |            |   5. Rsp    | 6. Distributed         |
   |             |            |------------&gt;|    Routing             |
   |             |     8. Redirect          |===========&gt;|           |
   |             |&lt;-------------------------|            7.IP Traffic|
   |             |            |             |            |==========&gt;|
   |             |         9. Distributed Routing        |           |
   |             |======================================&gt;|           |
   |             |            |             |           10.IP Traffic|
   |             |            |             |            |==========&gt;|
   |             |            |             |            |           |
   |             |            |             |            |           |

       Figure 4.  Another approach for optimized routing


+---+     +--------+   +--------+   +-------+  +--------+     +---+
|MN1|     |  MR11  |   |   MR2  |   |  LM1  |  |  MR31  |     |MN2|
+---+     +--------+   +--------+   +-------+  +--------+     +---+
  |            |            |           |           |           |
  |            |           1. Ongoing traffic       |           |
  |&lt;==========&gt;|&lt;==================================&gt;|&lt;========&gt; |
  |            |  2. Context|           |           |           |
  |            |  Transfer  |           |           |           |
  |            |&lt;----------&gt;|           |           | 3. IP     |
  |            |            |           |           | Traffic   |
  |            |            4. Distributed Routing  |&lt;========= |
  |            |&lt;===================================|           |
  |            |5. Transfer |           |           |           |
  |            |==========&gt; |           |           |           |
  |    6. IP Traffic        |           |           |           |
  |&lt;======================= |           |           |           |
  |            |            | 7. Redirect           |           |
  |            |----------------------------------&gt; |           |
  |            |            |           | +----------------+    |
  |            |            |           | | 8. Update      |    |
  |            |            |           | | Location of MN1|    |
  |            |            |           | +----------------+    |
  |            |            |           |           |  9. IP    |
  |            |            |           |           |  Traffic  |
  |            |            |10. Distributed Routing|&lt;==========|
  |    11. IP Traffic       |&lt;======================|           |
  |&lt;========================|                       |           |
  |            |            |                       |           |

        Figure 5.  Handover with Active Session
</code></pre>

<h2>Considerations of the Optimized Routing</h2>

<p>CN被假定为移动节点。这意味着CN必须连接到一个确定的MR，而且这个MR必须跟踪CN的位置并解析从CN到MN的所有数据包。但是，当CN为固定节点时，可能就没有这样为CN服务的MR了。</p>

<p>现实环境中，大多数的固定节点（CN）都以一种集中的方式被部署，例如CDN/IDC/Web服务器等。这些固定节点一般是由同一对接入路由器汇聚，即使那些固定的节点的接入运营商的IP承载网拓扑可能是非常复杂的。 图6是一个示例。</p>

<pre><code>   __________
  /    CN     \            ,--------.
((CDN\IDC\Web )---Access Router     `.
(   Server)   )    ,--'               `'
 \___________/     \                 _ -'
                    '--  MR  -----''
                          |
                          |
                         MN1

 Figure 6.  CNs are fixed nodes
</code></pre>

<p>对于在图6中描述的场景，直接的解决方案是利用所谓的汇聚接入路由器或网关路由器（即在上图标出的接入路由器）实现MR功能。</p>

<p>另一种替代方法是使用<a href="http://tools.ietf.org/html/draft-chan-dmm-framework-gap-analysis-06">I-D.chan-dmm-framework-gap-analysis</a>和<a href="http://tools.ietf.org/html/draft-wakikawa-mext-global-haha-spec-02">I-D.wakikawa-mext-global-haha-spec</a>中所描述的anycast机制。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[draft-luo-dmm-with-ipv6-prefix-properties-00]]></title>
    <link href="http://pengfx.github.io/blog/2013/05/06/draft-luo-dmm-with-ipv6-prefix-properties-00/"/>
    <updated>2013-05-06T10:45:00+08:00</updated>
    <id>http://pengfx.github.io/blog/2013/05/06/draft-luo-dmm-with-ipv6-prefix-properties-00</id>
    <content type="html"><![CDATA[<h1>Distributed Mobility Management Approaches with IPv6 Prefix Properties</h1>

<h3><a href="http://tools.ietf.org/html/draft-luo-dmm-with-ipv6-prefix-properties-00">draft-luo-dmm-with-ipv6-prefix-properties-00</a></h3>

<p>为了支持一个更分布的模型，本文扩展了现有的基于PMIP的移动性管理协议，并通过引入两个新的逻辑功能来实现分布式锚定和定位管理。鉴于MN可能并不总是需要移动性支持，即需要应用全局性前缀和其他的网络资源，本草案支持该选项以此来补充IPv6前缀源地址选择提示（即IPv6邻居发现协议和它的前缀信息选项）的扩展属性，实现了UE可以根据其服务/应用的移动性支持需求来选择IPv6的前缀。当MN支持扩展的前缀属性功能时，该草案允许ＭＮ可以根据 I-D.korhonen-dmm-prefix-properties 里描述的机制来选择合适的前缀。一旦确定了IPv6前缀，其余的ＤＭＭ机制则与I-D.luo-dmm-pmip-based-dmm-approach 类似。</p>

<hr />

<h2>Solution Overview</h2>

<p>两个新的逻辑功能:</p>

<ul>
<li>位置管理功能（LMF）， 用来维护IP地址与MN位置之间的匹配</li>
<li>分布式定位功能（DAF）用来对MN的第一跳路由器提供本地定位支持，并在 I-D.luo-dmm-pmip-based-dmm-approach 第七部分中进行了描述，被称为增强型的LMA（eLMA）并且与在 RFC5213 中描述的LMA具有相似的性质。</li>
</ul>


<p>DAF由分布式路由子功能（DRF）和分布式移动子功能（DMF）组成：</p>

<ul>
<li>DRF在MN的第一跳路由器上作为分布式隧道端点进行操作，以此来支持在两个DMM端点（例如MN与其相应的节点，如CN）之间的优化的路由。</li>
<li>DMF用来支持移动节点的移动性切换操作，减少在优化的路由建立的过程中数据包的丢失。</li>
</ul>


<p>在初始的MN附着中，本方案通过重新使用一个选项，即利用korhonen方案<a href="http://tools.ietf.org/html/draft-korhonen-dmm-prefix-properties-02">I-D.korhonen-dmm-prefix-properties</a>向MN传达IPv6前缀的源地址选择提示（例如在本草案中定义的前缀信息选项‘M’标志）。</p>

<pre><code>     Internet
        |           +-----+
        |           | LMF |
  Border Router     +-----+
        |
        +-----------------+---------
                          |
                      +---+---+
                      | eLMA1 |
                      | (DAF) |
                      +--+----+
           Global Prefix |  |Local Prefix
               (PreB)    |  |  (PreA)
                         V  V
                        +----+
                        | MN |
                        +----+
        IP1: From PreA (Local, without mobility)
        IP2: From PreB (Global, with mobility)

              Figure 1.  Initial Attach
</code></pre>

<p>当eLMA检测到一个初始的MN附件时，它会像该MN发出一个RA消息。该RA包括IPv6前缀，每个前缀都被它的属性进行标记，包括它的移动管理属性。根据移动管理属性，IPv6前缀被MN区分为两类，即全局前缀和本地前缀。它们被定义如下:</p>

<ul>
<li>全局前缀：如果一个来自全局前缀的IPv6地址被用作一个会话的源地址，那么将通过使用本草案中规定的移动性管理机制来向该会话提供完全的移动性支持。这意味着即使连接点改变了，地址始终保持有效。</li>
<li>本地前缀：如果一个来自本地前缀的IPv6地址被用作一个会话的源地址，不向该会话提供或者只提供有一定限制的移动性支持。那么当连接点改变的时候，地址可能不是有效的。</li>
</ul>


<p>根据已获取的移动性管理性质，MN根据IPv6前缀的两种分类来支持它的服务应用。如果MN的应用需要移动性支持，MN将通过让应用调用一个适当的API套接字扩展来从全局前缀中获取一个IPv6地址。反之，如果MN的应用不需要或者只要求有限的移动性支持，MN将通过调用另一个适当的API套接字扩展来从本地前缀中获取一个IPv6地址。</p>

<p>网络不会向本地IPv6前缀提供移动性，这意味着当MN改变它的连接点时（如eLMA)，那么前一个eLMA分配的本地前缀将被弃用\无效。当连接到下一个eLMA时，新的eLMA会分配一个新的本地前缀。</p>

<p>eLMA只为那些全局前缀向LMF更新位置信息。</p>

<h2>Detailed Scenarios and Approaches</h2>

<h4>Initial Attach</h4>

<p>当eLMA1检测到一个移动节点的最初链接，它向该移动节点发送一条RA消息。该RA包含两种前缀：本地前缀（PreA）和全局前缀（PreB）。eLMA应该根据[I-D.korhonen-dmm-prefix-properties]给PreA(如本地前缀)(http://tools.ietf.org/html/draft-korhonen-dmm-prefix-properties-02)分配一个高优先级，同时给PreB(如全局前缀)分配一个低优先级。</p>

<p>移动节点的应用可以选择一个合适的IPv6地址作为它的源地址，如<a href="http://tools.ietf.org/html/draft-korhonen-dmm-prefix-properties-02">I-D.korhonen-dmm-prefix-properties</a>中第4节描述的。</p>

<h4>Data forwarding</h4>

<pre><code>                                IP1 as destination:
                                common routing
                          |             +-------+       +----+
                          |             | eLMA3 |_______| CN |
       +-----+            +-------------+ (DAF) |       +----+
       | LMF |            |             +-------+
       +-----+            |     IP2 as destination:
                          |     Routing based on location
       --------------+----+     (e.g. IP in IP tunnel)
                     |
                 +---+---+
                 | eLMA1 |
                 | (DAF) |
                 +--+----+
      Global Prefix |  |Local Prefix
          (PreB)    |  |  (PreA)
                    V  V
                   +----+
                   | MN |
                   +----+
   IP1: From PreA (Local, without mobility)
   IP2: From PreB (Global, with mobility)

        Figure 2.1 Data forwarding mechanism
</code></pre>

<p>当通信节点（CN）向MN发送消息时，首先到达CN的eLMA3。eLMA3将根据目的IPv6地址的类别进行操作：</p>

<ol>
<li>如果目的IPv6包含本地IPv6前缀（图2.1中的IP1），eLMA3将使用通用的路由机制来发送IP包。</li>
<li>如果目的IPv6地址包含全局IPv6前缀（图2.1中的IP2），那么eLMA3将使用<a href="http://tools.ietf.org/id/draft-luo-dmm-pmip-based-dmm-approach-01.txt">I-D.luo-dmm-pmip-based-dmm-approach</a>7.2节中描述的路由机制来发送IP包。</li>
</ol>


<h4>Handoff Scenario</h4>

<pre><code>                                          IP1 as destination:
                                          can not be reachable
                                          after handoff
    Internet                              IP3 as destination:
        |                                 common routing
        |                                     +-------+       +----+
        |                              |      | eLMA3 |_______| CN |
        |          +-----+             +------+ (DAF) |       +----+
  Border Router    | LMF |             |      +-------+
        |          +-----+             |  IP2 as destination:
        |                              |  Routing based on location
        +-----+---------------------+--+
              |                     |
          +---+---+             +---+---+
          | eLMA2 |             | eLMA1 |
          | (DAF) |             | (DAF) |
          +-------+             +--+----+
Local Prefix |  |   Global Prefix   |  |Local Prefix
  (PreC)     |  |       (PreB)      |  |  (PreA)
             V  V                   V  V
            +----+                 +----+
            | MN |   &lt;------------ | MN |
            +----+                 +----+
 IP3: From PreC                IP1: From PreA
 (Local, without mobility)     (Local, without mobility)
 IP2:Keep unchanged            IP2: From PreB
 (Global, with mobility)       (Global, with mobility)

   Figure 3.1 Handover Scenario
</code></pre>

<p>从CN发送到IP1（从PreA中配置的）的通信将被IPv6路由系统自动丢弃；除非在前一个和下一个分布式定位之间建立一条临时的隧道用来维护到前一个本地前缀的可达性。依赖这些本地前缀的应用可能会遇到源IP地址变化的情况。</p>

<p>由eLMA2分配的RA消息携带的新的本地前缀（如图3.1中的PreC）目前有高优先级。MN将为PreC生成一个新的IPv6本地地址（图3.1中IP3）。</p>

<p>MN初始连接过程中eLMA1分配的全局前缀在RA消息中保持不变。为了维护这些全局地址的可达性，eLMA2应该向LMF执行位置更新，来维持全局前缀的可达性。<a href="http://tools.ietf.org/id/draft-luo-dmm-pmip-based-dmm-approach-01.txt">I-D.luo-dmm-pmip-based-dmm-approach</a>中的7.2节对切换细节进行了详细的描述。</p>

<p>因此，执行切换之后，既可以通过新的本地IPv6地址（如IP3）也可以通过全局IPv6地址（如IP2）来到达移动节点；如果在eLMA1和eLMA2之间有临时通道，也可以通过前一个本地IPv6地址（如IP1）到达。</p>

<p>是否在eLMA1与eLMA2之间建立临时隧道来维持本地前缀的可达，这取决于网络策略。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[draft-liu-dmm-dynamic-anchor-discussion-00]]></title>
    <link href="http://pengfx.github.io/blog/2013/05/06/draft-liu-dmm-dynamic-anchor-discussion-00/"/>
    <updated>2013-05-06T10:40:00+08:00</updated>
    <id>http://pengfx.github.io/blog/2013/05/06/draft-liu-dmm-dynamic-anchor-discussion-00</id>
    <content type="html"><![CDATA[<h1>DMM Dynamic Anchor Discussion</h1>

<p><em>给MN配置多个地址</em></p>

<h3><a href="http://tools.ietf.org/html/draft-liu-dmm-dynamic-anchor-discussion-00">draft-liu-dmm-dynamic-anchor-discussion-00</a></h3>

<p>There are many different proposals for DMM solution, one of those types of solution is called &#8220;dynamic anchor&#8221;. This document analyses the limitations of current dynamic anchor solution and discusses the possible solution to overcome those limitations.</p>

<h2>Problem of dynamic anchor and potential solution</h2>

<blockquote><p>draft-seite-dmm-dma-00</p></blockquote>

<ol>
<li><p>The main idea of dynamic anchor is <strong>distributing the mobility anchor function in the access router (MAR)</strong>.</p></li>
<li><p><strong>The newly initiated session is routed through the current MAR</strong>, only the <strong>original sessions that established before handover will be maintained at the previous anchor</strong>.</p></li>
<li>picture</li>
</ol>


<h3>Active session managment</h3>

<blockquote><p>Problem: how MAR2 know that there is an active session for HNP1 in MN?</p>

<blockquote><p>policy server to store</p></blockquote>

<p>MAR2/MAR1 has to have some mechanism to trigger the release HNP1</p>

<blockquote><p>Otherwise MAR1 will always be occupied by the MN, this leads system capacity waste</p>

<p>One of possible solution is that MAR2 can inspect the traffic that has the source address prefix equals to HNP1.</p>

<p>Need many Timers on MAR2, which leads system capacity consumed</p></blockquote></blockquote>

<h3>Soure address selection</h3>

<blockquote><p>RFC3484 specifies the source address selection rules for IPv6 but RFC3484 is not enough to cope with this situation since RFC3284 does not specify how to select source address for a particular application.</p></blockquote>

<p><strong>Solution</strong></p>

<blockquote><p>For any on-going session, keep to use the original address even there is a newly address been configured for the same interface.</p>

<p>For any new session, always choose to use the newly allocated address. The new MAR need to advertise the newly allocated prefix as the highest priority.</p></blockquote>

<h3>CN address selection</h3>

<p>From the CN’s perspective, the MN has multiple addresses, the CN needs to know which one it should use when it wants to initiate a session to MN.</p>

<h3>IPv4 support</h3>

<p>It will worse the IPv4 address depletion problem if use the dynamic anchor solution for IPv4 since each MN will need multiple IP addresses in that case.</p>

<h3>Resource consumption consideration</h3>

<ul>
<li><p>MN在多个MAR间频繁切换，消耗网络资源</p></li>
<li><p>同时还有被hacker利用，消耗网络资源的危险</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[draft-liu-dmm-address-selection-01]]></title>
    <link href="http://pengfx.github.io/blog/2013/05/06/draft-liu-dmm-address-selection-01/"/>
    <updated>2013-05-06T10:35:00+08:00</updated>
    <id>http://pengfx.github.io/blog/2013/05/06/draft-liu-dmm-address-selection-01</id>
    <content type="html"><![CDATA[<h1>Address Selection for DMM</h1>

<h3><a href="http://tools.ietf.org/html/draft-liu-dmm-address-selection-01">draft-liu-dmm-address-selection-01</a></h3>

<pre><code>移动节点有可能有多个移动锚点以及相对应的前缀。
在这种情况下，移动节点需要知道地址类型以选择一个正确的地址供应用使用。
本篇文档描述了一种扩展路由通告消息的机制，通过携带一个标志以用来鉴别前缀的性质。
</code></pre>

<hr />

<h2>Problem of address selection for DMM</h2>

<blockquote><p>draft-liu-dmm-dynamic-anchor-discussion-00</p></blockquote>

<p>分布式移动管理动态节点方案有地址选择的问题。这个问题的难点在于：移动节点并不知道多个前缀之间的区别。网络无法告知移动节点不同前缀性质之间的区别，而且也没有标准的机制让移动节点选择正确的前缀。</p>

<h2>Extension to Router Advertisment</h2>

<p>   移动IPv6 <a href="http://www.ietf.org/rfc/rfc3775.txt">RFC3775</a> 扩展了IPv6路由通告消息用来移动探测和本地代理信息广播。这篇文档建议对IPv6路由通告消息进行更多扩展以携带一个标志对它通告的前缀性质进行鉴别。<strong>H位</strong>被用来标识路由通告是由本地代理发送的。</p>

<pre><code>                  +----------+---------+-------------------+
                  |  Type    |  Code   |     Checksum      |
                  +----------+-+-+-+---+-------------------+
                  |Hop Limit |M|O|H|Re-|    Router Lifetime|
                  +----------+-+-+-+---+-------------------+
                  |          Reachable Time                |
                  +----------------------------------------+
                  |          Retrans Timer                 |
                  +----------------------------------------+
                  |          Options                       |
                  +----------------------------------------+
</code></pre>

<p>扩展前缀消息选项，添加一个“T”标志，其定义如下：</p>

<h4>T类型标志</h4>

<ul>
<li>00: 本地网络前缀。它表明这个前缀是由该移动节点所属的路由器分配和通告的。</li>
<li>01: 远程网络前缀。它表明这个前缀是除这个移动节点所属的路由外的其他路由分配的。</li>
<li>10: 保留</li>
<li><p>11: 保留</p>

<pre><code>          +-------------+------------+------------+-+-+-+--+---+
          |    Type     |    Length  |PrefixLength|L|A|R|T |R- |
          +-------------+------------+------------+-+-+-+--+---+
          |                 Valid Lifetime                     |
          +----------------------------------------------------+
          |                 Preferred Lifetime                 |
          +----------------------------------------------------+
          |                 Reserved                           |
          +----------------------------------------------------+
          |                                                    |
          |                 Prefix                             |
          +----------------------------------------------------+
</code></pre></li>
</ul>


<p><strong>路由用来鉴别前缀类型的机制在这篇文档的范围之外。比如说，路由能通过查询策略服务器来知道由哪个路由分配特定的前缀。</strong></p>

<h2>Mobile Node Operation</h2>

<p>移动节点通过路由通告消息的T标志识别前缀类型。移动节点上的应用可以通过这个信息来选择正确的IP地址。比如说，在一个在会话中，应用一直选择之前使用的前缀直至其被移交到新的位置。对于新初始的应用，他会使用被当前路由分配的前缀。</p>

<h4>An Example of How This Draft Works</h4>

<pre><code>     _______     _______    _______
    |       |   |       |  |       |
    |  CN1  |   |  CN2  |  |  CN3  |
    |_______|   |_______|  |_______|
        '           .            .
 Flow#1 '    Flow#2 .            |  Flow#3
        '   ...'''''.'''''''.... .
      ..'''         .           '''..
    .'  '      IP network        .   '.
    :   '           .            |    :
     '..'       +-------+        . ..'
        '''...  |       |.......'''
        '       | MAR2  | \      .
        '       |       |. \     |
        '       |       | . \    .
        '       +-------+\  .\   |
   +-------+   HNP2(T=00) \  + ------+
   |       |   HNP1(T=01)  \ |       | HNP3(T=00)
   | MAR1  |-----------------|  MAR3 | HNP2(T=01)
   |       | ''''''''''''''''|       | HNP1(T=01)
   |       |-----------------|       |
   +-------+                 +-------+
   HNP1(T=00)                   ' . |
                        Flow#1  ' . .  Flow#3
                                ' . |
     +-----+            Flow#2 +-----+
     | MN  | -----move-------&gt; | MN  |
     +-----+                   +-----+
</code></pre>

<ol>
<li>当移动节点附属到MAR1，MAR1发送了路由通告消息，包含前缀信息选项的移动节点的HNP1以及T标志位设置为00。这表明HNP1是由当前路由（MAR1）分配和通告的本地网络前缀。移动节点能通过取自HNP1的IPv6地址初始化与CN1的会话（如图中的flow#1）。</li>
<li>当移动节点切换至MAR2（flow#1在移动节点切换时仍在持续），MAR2发送包含了移动节点的HNP2的路由通告消息，其类型标志T被设置成00，同时之前的前缀（HNP1）被设置成01。移动节点就会识别HNP2是当前本地网络前缀，而HNP1是远程网络前缀。这时，移动节点会用取自HNP2的IPv6地址作为源地址初始化一个新的与CN2（如图中的flow#2）会话。因为IPv6地址取自本地网络前缀（HNP2），flow#2会使用常规的IPv6协议。对于flow#1，MAR1充当LMA，MAR2充当MAG。</li>
<li>当移动节点切换至MAR3时（移动节点切换时flow#1和flow#2仍在持续），MAR3发送包含了移动节点新的前缀（HNP3）的路由通告消息，类型标志（T）被置为00，而之前的前缀（HNP1、HNP2）的类型标志（T）被置为01。这表明HNP3是本地网络前缀，而HNP1和HNP2是远程网络前缀。这时，移动节点把从HNP3取得的IPv6地址作为原地址，初始化与CN3的会话（比如图中的flow#3）。flow#3使用常规的IPv6协议。</li>
</ol>


<h4>MN Handoffs From MAR Back to Its Previous MAR</h4>

<p>上述过程的逆过程。略。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[draft-korhonen-dmm-prefix-properties-03]]></title>
    <link href="http://pengfx.github.io/blog/2013/05/06/draft-korhonen-dmm-prefix-properties-03/"/>
    <updated>2013-05-06T10:29:00+08:00</updated>
    <id>http://pengfx.github.io/blog/2013/05/06/draft-korhonen-dmm-prefix-properties-03</id>
    <content type="html"><![CDATA[<h1>IPv6 Prefix Mobility Management Properties</h1>

<h3><a href="http://tools.ietf.org/html/draft-korhonen-dmm-prefix-properties-03">draft-korhonen-dmm-prefix-properties-03.txt</a></h3>

<pre><code>这篇规范定义并扩展IPv6邻居发现协议的前缀信息选项，扩展其标志位来描述与前缀相关的移动管理性质。
这篇draft更新了[RFC4861](http://tools.ietf.org/rfc/rfc4861.txt)。
</code></pre>

<hr />

<h2>Background and Motivation</h2>

<ul>
<li>非最优路由</li>
<li>过多的隧道，为了维护移动性相关绑定而增加的信令</li>
<li>集中式的MAG下流量聚合</li>
</ul>


<p>In general, it is observed that most applications do not need IP level mobility, and work just
fine with &#8220;temporary&#8221; IP addresses that come and go. However, IP mobility still has its virtues making the applications unaware of mobility, and certain wireless mobile networking architecture make extensive use of network based IP mobility.</p>

<p>在许多情况下，这可能会导致MN有多个地址被使用，但是其中一些提供了移动性，而另一些没有提供。不得不提供方法来让终端主机区分是否是提供了移动性的地址，还是一些生存期很短并且只能在一个受限的拓扑域使用的地址。</p>

<p><strong>这篇draft提供了IPv6地址管理的扩展以及源地址的选择，这样终端主机（以及它的应用）就能够为它们的需求选择一个合适的地址。</strong></p>

<h2>Option Formats</h2>

<pre><code>'M' 长为1位的标志，描述了前缀的移动性，其性质被定义为：
0 这个前缀没有相关的基于网络的移动性，这个前缀以RFC4861中所提供的方式进行处理。
1 这个前缀提供了基于网络的移动性并且可能保持前缀未改变的有效时间。


'S' 长为1位的标志，它能够提供与使用前缀相关的安全性质的提示。

'Class' 长达14位的前缀分类，这个前缀分类加上了移动性与安全性的补充信息。0被保留，该值没有描述前缀的任何信息。对于未知的分类都将其值置为0。

我们将'M'位、'S'位以及'class’的结合称之为前缀性质。
</code></pre>

<h2>Host Considerations</h2>

<blockquote><p>[I-D.liu-dmm-mobility-api]</p></blockquote>

<h4>内部数据结构</h4>

<p>主机内部数据结构需要被前缀性质信息扩展，这些信息与已学习的前缀及配置地址相关联。关于这一点是如何完成是需要由具体的主机来指定的。一个应用怎样才能够知道或询问到一个地址或一个前缀的移动性也是由具体主机的实现来决定的。一个可能性是通过socket API的扩展来提供这样的信息。（关于这点可以看 <a href="http://tools.ietf.org/id/draft-korhonen-dmm-prefix-properties-03.txt">I-D.liu-dmm-mobility-api</a> 中的讨论）。其它的可能性包括ioctl（）的扩展以及NetLink的扩展。</p>

<h4>默认地址选择</h4>

<p>“前缀性质”提供的信息只能用来作为一种提示。它并不会自动的影响已经存在了的东西<a href="http://tools.ietf.org/rfc/rfc6724.txt">RFC6724</a>，除了稍后将要描述的&#8217;M&#8217;标志位之外。对于主机的策略表来说，一个详细的规则不得不被一个应用或者一些守护进程插入。在可选情况下，一个应用能够通过在<a href="http://tools.ietf.org/id/draft-korhonen-dmm-prefix-properties-03.txt">I-D.liu-dmm-mobility-api</a>中讨论的socket API的扩展来表达地址移动性的优先级，这就意味着库文件或中间件不得不修改策略表或算法。</p>

<blockquote><p>The ’M’ flag defines the prefix preference for an IP stack that
understands the extensions defined in this specification. The IP
stack SHOULD use the following preferences to supersede [RFC6724]
Source Address Selection Rule 8 when selecting a default source
address among multiple choices and an application has not explicitly
indicate what kind of source address it prefers:</p>

<ul>
<li><p>0 Default preference.</p></li>
<li><p>1 Low preference.</p></li>
</ul>
</blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[draft-bernardos-dmm-distributed-anchoring-01]]></title>
    <link href="http://pengfx.github.io/blog/2013/05/06/draft-bernardos-dmm-distributed-anchoring-01/"/>
    <updated>2013-05-06T10:21:00+08:00</updated>
    <id>http://pengfx.github.io/blog/2013/05/06/draft-bernardos-dmm-distributed-anchoring-01</id>
    <content type="html"><![CDATA[<h1>PMIPv6-based distributed anchoring</h1>

<h3><a href="http://tools.ietf.org/html/draft-bernardos-dmm-distributed-anchoring-01">draft-bernardos-dmm-distributed-anchoring-01</a></h3>

<blockquote><p> <a href="http://tools.ietf.org/html/draft-bernardos-dmm-distributed-anchoring-02">draft-bernardos-dmm-distributed-anchoring-02</a> April 8, 2013</p>

<p>02相比01变化很小，可以忽略两者间的差异</p></blockquote>

<p>The draft focuses on the required extensions to effectively support simultaneously anchoring several flows at different distributed gateways.</p>

<hr />

<h2>1.  Introduction</h2>

<p>The main contribution of this draft is the definition of the mechanisms required to support the operation of such a network-based mobility solution when several flows are simultaneously anchored at different D-GWs, by introducing the concept of <strong>Distributed Logical Interface (DLIF)</strong>.</p>

<p>The document also defines the <strong>required PMIPv6 signaling extensions</strong>.</p>

<p> Last, but not least, the solution is also extended to <strong>provide session continuity across different domains</strong>.</p>

<h2>2.  Terminology</h2>

<ul>
<li><p>D-GW (Distributed Gateway).移动节点使用的第一跳IP路由器。它为每一个附加的移动节点提供一个IPv6前缀。</p></li>
<li><p>Anchoring D-GW. 前访问过的锚定一个仍被移动节点使用的IPv6地址前缀的D-GW。</p></li>
<li><p>Serving D-GW.MN当前连接到的D-GW。</p></li>
<li><p>DLIF (Distributed Logical Interface).位于D-GW的IP协议栈的逻辑接口。对于每个活动的由移动节点使用的前缀，Serving D-GW具有DLIF配置（相关联到Anchoring D-GW）。这种方式下，Serving D-GW对每一个MN充当多个路由器，每一个对应到 active Anchoring D-GW。</p></li>
<li>HSS(Home Subscriber Server).3GPP&#8230;.</li>
</ul>


<h2>3.  Solution&#8217;s overview</h2>

<p>当移动节点连接到一个D-GW（初始连接或切换），D-GW作为路由器提供给MN一个IPv6前缀。MN独占前缀。D-GW充当普通路由器。</p>

<p>当移动节点进行切换时，会附加到一个新的D-GW并且由于获得新的地址前缀和锚定到新的服务D-GW，将配置新的IPv6地址。D-GW充当普通路由器。
如果anchoring D-GWs下发的前缀上还有active traffic，或者仅仅是想维持这个前缀的可达，serving D-GW充当MAG，anchoring D-GWs充当LMA。PBU，PBA。隧道。</p>

<p>serving D-GW上获取相关联的anchoring D-GWs超出本文范围。Among the possible mechanisms that can be used to
let the D-GW know about the prefixes that should be kept reachable, we can cite for instance layer-2 triggers/signaling.Regarding the mapping of IPv6 prefixes to anchoring D-GWs, there might be either fully distributed mechanisms in place, or the information can be maintained in a centralized repository (e.g.,in the HSS, using a centralized LMA <a href="http://tools.ietf.org/html/draft-bernardos-dmm-pmip-01">I-D.bernardos-dmm-pmip</a>, etc.).</p>

<pre><code>        +-----+      +-------+      +-------+      +-------------+
        | MN1 |      | D-GW1 |      | D-GW2 |      | CN@Internet |
        +-----+      +-------+      +-------+      +-------------+
           |             |              |                 |
           |  attachment |              |                 |
           |&lt;...........&gt;|              |                 |
           |  prefA::/64 |              |                 |
           |&lt;------------|              |                 |
configures |             |              |                 |
prefA::MN1 |             |              |                 |
           |          (traffic using prefA::MN1)          |
           |&lt;------------|-------------------------------&gt;|
           |             |              |                 |
           |         handover           |                 |
           /............................/                 |
           |             |   prefB::/64 |                 |
           |&lt;---------------------------|                 |
configures |             |         PBU  |                 |
prefB::MN1 |      tunnel |&lt;-------------|                 |
and keeps  |      set-up |  PBA         |                 |
  using    |             |-------------&gt;| tunnel          |
prefA::MN1 |             |              | set-up          |
           |          (traffic using prefB::MN1)          |
           |&lt;---------------------------|----------------&gt;|
           |          (traffic using prefA::MN1)          |
           |             |&lt;------------------------------&gt;|
           |             |&lt;============&gt;|                 |
           |&lt;--------------------------&gt;|                 |
           |             |              |                 |

              Figure 1: Basic operation of the solution
</code></pre>

<h2>4.  Simultaneous anchoring of multiple flows (single operator)</h2>

<pre><code>如何给MN配置多个地址，并使地址具有优先级
</code></pre>

<h2>5.  Simultaneous anchoring of multiple flows (multiple operators)</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[git]]></title>
    <link href="http://pengfx.github.io/blog/2013/04/23/git/"/>
    <updated>2013-04-23T13:55:00+08:00</updated>
    <id>http://pengfx.github.io/blog/2013/04/23/git</id>
    <content type="html"><![CDATA[<h1>git 用法简单整理</h1>

<h2>创建 git 仓库</h2>

<h3>1. 初始化 git 仓库</h3>

<pre><code>mkdir project # 创建项目目录
cd project # 进入到项目目录
git init # 初始化 git 仓库。此命令会在当前目录新建一个 .git 目录，用于存储 git 仓库的相关信息
</code></pre>

<h3>2. 初始化提交</h3>

<pre><code>touch README
git add . # 将当前目录添加到 git 仓库中， 使用 git add -A 则是添加所有改动的文档
git commit -m "Initial commit"
git remote add origin git@github.com:pengfx/repo.git # 设置仓库
</code></pre>

<h3>3. 修补提交（修补最近一次的提交而不创建新的提交）</h3>

<pre><code>git commit --amend -m "commit message."
</code></pre>

<h3>4. 提交冲突时可以合并后再推送</h3>

<pre><code>git pull # 获取远程版本库提交与本地提交进行合并
git push # 提交
</code></pre>

<h2>使用别人的仓库</h2>

<pre><code>git clone http://path/to/git.git # clone 的内容会放在当前目录下的新目录
</code></pre>

<h2>将代码从本地回传到仓库</h2>

<pre><code>git push -u origin master
</code></pre>

<h2>使用 git status 查看文件状态</h2>

<pre><code>git status
</code></pre>

<h2>查看提交日志</h2>

<pre><code>git log # 查看提交信息
git log --pretty=oneline # 以整洁的单行形式显示提交信息
git log --stat # 查看提交信息及更新的文件
</code></pre>

<h2>Git 分支</h2>

<pre><code>git branch # 查看分支
git branch 6.x-1.x # 添加分支 6.x-1.x
git branch checkout master # 切换到主分支
git branch -d 6.x-1.x # 删除分支 6.x-1.x
git push origin :branchname # 删除远端分支
</code></pre>

<h2>Git 标签</h2>

<pre><code>git tag # 查看分支
git tag 6.x-1.0 # 添加标签 6.x-1.0
git show 6.x-1.0 # 查看标签 6.x-1.0 的信息
git tag -a 6.x-1.0 965e066 # 为之前提交的信息记录 965e066 加上标签
git push --tags # 提交时带上标签信息
git push origin :/refs/tags/tagname # 删除远端标签
</code></pre>

<h2>从 git 仓库中导出项目</h2>

<pre><code>git archive --format tar --output /path/to/file.tar master # 将 master 以 tar 格式打包到指定文件
</code></pre>

<h2>使用 Git 的一些基本守则</h2>

<p>当要commit/提交patch时：</p>

<ul>
<li><p>使用 git diff &#8211;check 检查行尾有没有多余的空白</p></li>
<li><p>每个 commit 只改一件事情。如果一个文档有多个变更，使用 git add &#8211;patch 只选择文档中的部分变更进入 stage
写清楚 commit message</p></li>
</ul>


<p>参考<a href="http://lugir.com/git-basic.html">lugir.com</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[draft-bernardos-mext-dmm-pmip-01]]></title>
    <link href="http://pengfx.github.io/blog/2013/04/22/draft-bernardos-mext-dmm-pmip-01/"/>
    <updated>2013-04-22T21:04:00+08:00</updated>
    <id>http://pengfx.github.io/blog/2013/04/22/draft-bernardos-mext-dmm-pmip-01</id>
    <content type="html"><![CDATA[<h1>A PMIPv6-based solution for Distributed Mobility Management</h1>

<h3><a href="http://tools.ietf.org/html/draft-bernardos-mext-dmm-pmip-01">draft-bernardos-mext-dmm-pmip-01</a></h3>

<blockquote><p>July 11, 2011</p></blockquote>

<pre><code>本文描述了一种在代理移动IPv6域中分散数据转发平面的解决方案，即试图避免（数据包）经过LMA时所引入的次优数据路径问题。
</code></pre>

<hr />

<h2>1. Introduction</h2>

<p>集中式的移动性解决方案容易出现一些<strong>问题和制约</strong>：更长（次优）的路由路径、可扩展性问题、信令开销（最有可能是一个更长的相关性切换时延）、更复杂的网络部署、由潜在的单点故障引起的更高的脆弱性、移动性管理服务中粒度的缺乏。</p>

<p>本文基于网络的移动性支持来实现DMM。</p>

<h2>2.  Terminology</h2>

<blockquote><p>MAAR (Mobility Anchor and Access Router).移动节点连接的第一跳路由器。它们也负责对它们所匹配的IPv6前缀的移动性管理。</p>

<p>CMD (Central Mobility Database).在移动域中为移动节点存储绑定缓存入口(BCE)的节点</p>

<p>A-MAAR(Anchor MAAR) 。移动节点刚访问过的MAAR，它通告了MN在active flow中使用的IPv6前缀。</p>

<p>S-MAAR (Serving MAAR)。 移动节点现在连接的MAAR。</p></blockquote>

<h2>3.  Description of the solution</h2>

<pre><code>思想：使移动锚点更靠近移动节点，从而克服传统集中式移动性管理的限制
本文中，中央锚点被移动到网络的边缘，部署在移动节点的默认网关中。
也就是说，为一系列的移动节点提供IP连通性的锚点，同时也是这些移动节点的移动性管理者。
</code></pre>

<h4>3.1.  Initial registration</h4>

<p>MAAR像普通路由器一样工作，这样就没有多余的封装和处理产生。</p>

<pre><code> +-----+      +---+                +--+
 |MAAR1|      |CMD|                |CN|
 +-----+      +---+                +*-+
    |           |                   *
   MN           |                   *     +---+
attach detection|               *****    _|CMD|_
    |           |         flow1 *       / +-+-+ \
    |           |               *      /    |    \
    |--- PBU --&gt;|               *     /     |     \
    |           |               *    /      |      \
    |          BCE          +---*-+-'    +--+--+    `+-----+
    |       creation        |   * |      |     |     |     |
    |           |           |MAAR1+------+MAAR2+-----+MAAR3|
    |&lt;-- PBA ---|           |   * |      |     |     |     |
    |           |           +---*-+      +-----+     +-----+
    |           |               *
    |           |         Pref1 *
    |           |              +*-+
    |           |              |MN|
    |           |              +--+

(Operations sequence)                (Packets flow)

             Figure 1: First attachment to the network
</code></pre>

<h4>3.2.  The CMD as PBU/PBA relay</h4>

<p>两个MAAR之间就建立隧道</p>

<pre><code>+-----+      +---+      +-----+           +--+            +--+
|MAAR1|      |CMD|      |MAAR2|           |CN|            |CN|
+-----+      +---+      +-----+           +*-+            +*-+
  |           |           |               *               *
  |           |          MN               *     +---+     *
  |           |        attach.        *****    _|CMD|_    *
  |           |          det.   flow1 *       / +-+-+ \   *flow2
  |           |&lt;-- PBU ---|           *      /    |    \  *
  |          BCE          |           *     /     | *******
  |        check+         |           *    /      | *    \
  |        update         |       +---*-+-'    +--+-*+    `+-----+
  |&lt;-- PBU ---|           |       |   * |      |    *|     |     |
route         |           |       |MAAR1|______|MAAR2+-----+MAAR3|
update        |           |       |   **(______)**  *|     |     |
  |--- PBA --&gt;|           |       +-----+      +-*--*+     +-----+
  |         BCE           |                      *  *
  |        update         |                Pref1 *  *Pref2
  |           |--- PBA --&gt;|                     +*--*+
  |           |         route         ---move--&gt;|*MN*|
  |           |         update                  +----+

     (Operations sequence)                (Packets flow)

         Figure 2: Scenario after a handover, CMD as relay
</code></pre>

<p>当CMD从新的S-MAAR收到第一个PBU后，它向所有的A-MAAR转发PBU的拷贝，这个PBU在BCE中表示为现在的P-CoA(例如切换之前的MAAR)和以前的P-CoA。它们用PBA回复CMD，CMD将这些PBA聚集成一个PBA来通知S-MAAR，这样就最终建立了与A-MAARs之间的隧道。</p>

<h4>3.3.  The CMD as MAAR locator</h4>

<p>允许A-MAAR直接向新的S-MAAR发送信息</p>

<pre><code>+-----+      +---+      +-----+           +--+            +--+
|MAAR1|      |CMD|      |MAAR2|           |CN|            |CN|
+-----+      +---+      +-----+           +*-+            +*-+
  |           |           |               *               *
  |           |          MN               *     +---+     *
  |           |        attach.        *****    _|CMD|_    *
  |           |          det.   flow1 *       / +-+-+ \   *flow2
  |           |&lt;-- PBU ---|           *      /    |    \  *
  |          BCE          |           *     /     | *******
  |        check+         |           *    /      | *    \
  |        update         |       +---*-+-'    +--+-*+    `+-----+
  |&lt;-- PBU ---|           |       |   * |      |    *|     |     |
route         |           |       |MAAR1|______|MAAR2+-----+MAAR3|
update        |           |       |   **(______)**  *|     |     |
  |--------- PBA --------&gt;|       +-----+      +-*--*+     +-----+
  |--- PBA --&gt;|         route                    *  *
  |          BCE        update             Pref1 *  *Pref2
  |         update        |                     +*--*+
  |           |           |           ---move--&gt;|*MN*|
  |           |           |                     +----+

     (Operations sequence)                (Packets flow)

        Figure 3: Scenario after a handover, CMD as locator
</code></pre>

<h4>3.4.  The CMD as PBU/PBA proxy</h4>

<p>CMD在通知A-MAAR位置变化之前，向新的S-MAAR发送PBA</p>

<pre><code>+-----+      +---+      +-----+           +--+            +--+
|MAAR1|      |CMD|      |MAAR2|           |CN|            |CN|
+-----+      +---+      +-----+           +*-+            +*-+
   |           |           |               *               *
   |           |          MN               *     +---+     *
   |           |        attach.        *****    _|CMD|_    *
   |           |          det.   flow1 *       / +-+-+ \   *flow2
   |           |&lt;-- PBU ---|           *      /    |    \  *
   |          BCE          |           *     /     | *******
   |        check+         |           *    /      | *    \
   |        update         |       +---*-+-'    +--+-*+    `+-----+
   |&lt;-- PBU ---x--- PBA --&gt;|       |   * |      |    *|     |     |
route          |         route     |MAAR1|______|MAAR2+-----+MAAR3|
update         |         update    |   **(______)**  *|     |     |
   |--- PBA  -&gt;|           |       +-----+      +-*--*+     +-----+
   |          BCE          |                      *  *
   |         update        |                Pref1 *  *Pref2
   |           |           |                     +*--*+
   |           |           |           ---move--&gt;|*MN*|
   |           |           |                     +----+

     (Operations sequence)                (Packets flow)

         Figure 4: Scenario after a handover, CMD as proxy
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[test clone]]></title>
    <link href="http://pengfx.github.io/blog/2013/04/22/test-clone/"/>
    <updated>2013-04-22T20:46:00+08:00</updated>
    <id>http://pengfx.github.io/blog/2013/04/22/test-clone</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hello World]]></title>
    <link href="http://pengfx.github.io/blog/2013/04/16/hello-world/"/>
    <updated>2013-04-16T17:57:00+08:00</updated>
    <id>http://pengfx.github.io/blog/2013/04/16/hello-world</id>
    <content type="html"><![CDATA[<p>Hello World
你好，世界</p>
]]></content>
  </entry>
  
</feed>
