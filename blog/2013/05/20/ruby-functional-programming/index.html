
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Ruby 函数式编程 - My Blog</title>
  <meta name="author" content="Peng Feixiang">

  
  <meta name="description" content="Ruby 函数式编程 by Arnau Sanchez 本文档翻译自 Arnau Sanchez (tokland)所编译的这份文档 RubyFunctionalProgramming。 同时也有日文版本。 目录 简介
理论部分
Ruby的函数式编程 不要更新变量
用 Blocks 作为高阶函数 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://pengfx.github.io/blog/2013/05/20/ruby-functional-programming">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="My Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">My Blog</a></h1>
  
    <h2>Hello</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:pengfx.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">Ruby 函数式编程</h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-05-20T17:20:00+08:00" pubdate data-updated="true">May 20<span>th</span>, 2013</time>
        
      </p>
    
  </header>


<div class="entry-content"><h1>Ruby 函数式编程 by Arnau Sanchez</h1>

<p>本文档翻译自 Arnau Sanchez (tokland)所编译的这份文档 <a href="http://code.google.com/p/tokland/wiki/RubyFunctionalProgramming">RubyFunctionalProgramming</a>。</p>

<p>同时也有<a href="http://www.h6.dion.ne.jp/~machan/misc/FPwithRuby.html">日文版本</a>。</p>

<h2>目录</h2>

<ul>
<li><a href="#-1">简介</a></li>
<li><a href="#-2">理论部分</a></li>
<li><a href="#ruby">Ruby的函数式编程</a>

<ul>
<li><a href="#-3">不要更新变量</a></li>
<li><a href="#-blocks-">用 Blocks 作为高阶函数</a></li>
<li><a href="#-6">面向对象与函数式编程</a></li>
<li><a href="#-7">万物皆表达式</a></li>
<li><a href="#-8">递归</a></li>
<li><a href="#-9">惰性枚举器</a></li>
<li><a href="#-11">一个实际的例子</a></li>
</ul>
</li>
<li><a href="#-12">结论</a></li>
<li><a href="#-13">展示</a></li>
<li><a href="#-14">延伸阅读</a></li>
</ul>


<h2>简介</h2>

<blockquote><p>命令式编程比较牛吗？
不！不！不！只是比较快，比较简单，比较诱人而已。</p></blockquote>

<pre><code>x = x + 1
</code></pre>

<p>在以前上小学的美好回忆里，我们可能都曾对上面这个式子感到困惑。这个 <code>x</code> 到底是什么呢？为什么加了一之后，<code>x</code> 仍然还是 <code>x</code>。</p>

<p>不知道为什么，我们就开始写程序了，也就不在乎这是为什么了。心想：“嗯”，“这不是什么大问题，编程就是事情做完最重要，没有必要去挑剔数学的纯粹性 （让大学里的大胡子教授们去烦恼就好）” 。但我们错了，也因此付出极高的代价，只因我们不了解它。</p>

<h2>理论部分</h2>

<p><a href="http://en.wikipedia.org/wiki/Functional_programming">维基百科</a>的解释：“函数式编程是一种写程序的范式，将计算视为对数学函数的求值，并避免使用状态及可变的数据” 换句话说，函数式编程提倡没有副作用的代码，不改变变量的值。这与命令式编程相反，命令式编程强调改变状态。</p>

<p>令人惊讶的是，函数式编程就这样而已。那…有什么好处呢？</p>

<ul>
<li><p>更简洁的代码：“变量”一旦定义之后就不再改动，所以我们不需要追踪变量的状态，就可以理解一个函数、方法、类别、甚至是整个项目是怎么工作的。</p></li>
<li><p>引用透明：表达式可以用本身的值换掉。如果我们用同样的参数调用一个函数，我们确信输出会是一样的结果（没有其它的状态可改变它的值）。这也是为什么爱因斯坦说：“重复做一样的事却期望不同的结果”是疯狂的理由。</p></li>
</ul>


<p>引用透明打开了前往某些美妙事物的大门</p>

<ul>
<li><p>并行化：如果调用函数是各自独立的，则他们可以在不同的进程甚至是机器里执行，而不会有竞态条件的问题。“平常” 写并发程序讨厌的细节（锁、semaphore…等）在函数式编程里面通通消失不见了。</p></li>
<li><p>记忆化：由于函数调用的结果等于它的返回值，我们可以把这些值缓存起来。</p></li>
<li><p>模块化：代码里不存有状态，所以我们可以将项目用小的黑箱连结起来，函数式编程提倡自底向上的编程风格。</p></li>
<li><p>容易调试：函数彼此互相隔离，只依赖输入与输出，所以很容易调试。</p></li>
</ul>


<h2>Ruby的函数式编程</h2>

<p>一切都是这么美好，但怎样才能将函数式编程，应用到每天写 Ruby（Ruby 不是个函数式语言）的程序开发里呢？函数式编程广义来说，是一种风格，可以用在任何语言。当然啦，用在特别为这种范式打造的语言里显得更自然，但某种程度上来说，可以应用到任何语言。</p>

<p>让我们先理清这一点：本文没有要提倡古怪的风格，比如仅仅为了要延续理论函数式编程的纯粹性所带来的古怪风格。反之，我想说的重点是，我们应该 <strong>当可以提升代码的品质的时候，才使用函数式编程</strong> ，不然这只不过是个糟糕的解决办法。</p>

<h3>不要更新变量</h3>

<p>别更新它们，创造新的变量。</p>

<h4>不要对数组或字串做 <code>append</code></h4>

<p>No:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">indexes</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="o">]</span>
</span><span class='line'><span class="n">indexes</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span>
</span><span class='line'><span class="n">indexes</span> <span class="c1"># [1, 2, 3, 4]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Yes：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">indexes</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="o">]</span>
</span><span class='line'><span class="n">all_indexes</span> <span class="o">=</span> <span class="n">indexes</span> <span class="o">+</span> <span class="o">[</span><span class="mi">4</span><span class="o">]</span> <span class="c1"># [1, 2, 3, 4]</span>
</span></code></pre></td></tr></table></div></figure>


<h4>不要更新 hash</h4>

<p>No:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">hash</span> <span class="o">=</span> <span class="p">{</span><span class="ss">:a</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="ss">:b</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="p">}</span>
</span><span class='line'><span class="nb">hash</span><span class="o">[</span><span class="ss">:c</span><span class="o">]</span> <span class="o">=</span> <span class="mi">3</span>
</span><span class='line'><span class="nb">hash</span>
</span></code></pre></td></tr></table></div></figure>


<p>Yes:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">hash</span> <span class="o">=</span> <span class="p">{</span><span class="ss">:a</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="ss">:b</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="p">}</span>
</span><span class='line'><span class="n">new_hash</span> <span class="o">=</span> <span class="nb">hash</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="ss">:c</span> <span class="o">=&gt;</span> <span class="mi">3</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h4>牵扯到内存位置的地方，不要使用破坏性方法。</h4>

<p>No:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">string</span> <span class="o">=</span> <span class="s2">&quot;hello&quot;</span>
</span><span class='line'><span class="n">string</span><span class="o">.</span><span class="n">gsub!</span><span class="p">(</span><span class="sr">/l/</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">)</span>
</span><span class='line'><span class="n">string</span> <span class="c1"># &quot;hezzo&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Yes:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">string</span> <span class="o">=</span> <span class="s2">&quot;hello&quot;</span>
</span><span class='line'><span class="n">new_string</span> <span class="o">=</span>  <span class="n">string</span><span class="o">.</span><span class="n">gsub</span><span class="p">(</span><span class="sr">/l/</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">)</span> <span class="c1"># &quot;hezzo&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<h4>如何累积值</h4>

<p>No:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">output</span> <span class="o">=</span> <span class="o">[]</span>
</span><span class='line'><span class="n">output</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span>
</span><span class='line'><span class="n">output</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span> <span class="k">if</span> <span class="n">i_have_to_add_two</span>
</span><span class='line'><span class="n">output</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span>
</span></code></pre></td></tr></table></div></figure>


<p>Yes:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">output</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span> <span class="k">if</span> <span class="n">i_have_to_add_two</span><span class="p">),</span> <span class="mi">3</span><span class="o">].</span><span class="n">compact</span>
</span></code></pre></td></tr></table></div></figure>


<h3>用 Blocks 作为高阶函数</h3>

<p>如果一个语言要搞函数式，会需要高阶函数。高阶函数是什么？函数可以接受别的函数作为参数，并可以返回函数，就这么简单。</p>

<p>Ruby (与 Smalltalk 还有其它语言）在这个方面上非常特别，语言本身就内置这个功能： <strong>blocks</strong> 区块。区块是一段匿名的代码，你可以随意的传来传去或是执行它。让我们看区块的典型用途，来构造函数式编程的构造子。</p>

<h4>init-empty + each + push = map</h4>

<p>No:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">dogs</span> <span class="o">=</span> <span class="o">[]</span>
</span><span class='line'><span class="o">[</span><span class="s2">&quot;milu&quot;</span><span class="p">,</span> <span class="s2">&quot;rantanplan&quot;</span><span class="o">].</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="nb">name</span><span class="o">|</span>
</span><span class='line'>  <span class="n">dogs</span> <span class="o">&lt;&lt;</span> <span class="nb">name</span><span class="o">.</span><span class="n">upcase</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'><span class="n">dogs</span> <span class="c1"># =&gt; [&quot;MILU&quot;, &quot;RANTANPLAN&quot;]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Yes:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">dogs</span> <span class="o">=</span> <span class="o">[</span><span class="s2">&quot;milu&quot;</span><span class="p">,</span> <span class="s2">&quot;rantanplan&quot;</span><span class="o">].</span><span class="n">map</span> <span class="k">do</span> <span class="o">|</span><span class="nb">name</span><span class="o">|</span>
</span><span class='line'>  <span class="nb">name</span><span class="o">.</span><span class="n">upcase</span>
</span><span class='line'><span class="k">end</span> <span class="c1"># =&gt; [&quot;MILU&quot;, &quot;RANTANPLAN&quot;]</span>
</span></code></pre></td></tr></table></div></figure>


<h4>init-empty + each + conditional push -> select/reject</h4>

<p>No:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">dogs</span> <span class="o">=</span> <span class="o">[]</span>
</span><span class='line'><span class="o">[</span><span class="s2">&quot;milu&quot;</span><span class="p">,</span> <span class="s2">&quot;rantanplan&quot;</span><span class="o">].</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="nb">name</span><span class="o">|</span>
</span><span class='line'>  <span class="k">if</span> <span class="nb">name</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">4</span>
</span><span class='line'>    <span class="n">dogs</span> <span class="o">&lt;&lt;</span> <span class="nb">name</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'><span class="n">dogs</span> <span class="c1"># =&gt; [&quot;milu&quot;]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Yes:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">dogs</span> <span class="o">=</span> <span class="o">[</span><span class="s2">&quot;milu&quot;</span><span class="p">,</span> <span class="s2">&quot;rantanplan&quot;</span><span class="o">].</span><span class="n">select</span> <span class="k">do</span> <span class="o">|</span><span class="nb">name</span><span class="o">|</span>
</span><span class='line'>  <span class="nb">name</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">4</span>
</span><span class='line'><span class="k">end</span> <span class="c1"># =&gt; [&quot;milu&quot;]</span>
</span></code></pre></td></tr></table></div></figure>


<h4>initialize + each + accumulate -> inject</h4>

<p>No:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">length</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'><span class="o">[</span><span class="s2">&quot;milu&quot;</span><span class="p">,</span> <span class="s2">&quot;rantanplan&quot;</span><span class="o">].</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">dog_name</span><span class="o">|</span>
</span><span class='line'>  <span class="n">length</span> <span class="o">+=</span> <span class="n">dog_name</span><span class="o">.</span><span class="n">length</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'><span class="n">length</span> <span class="c1"># =&gt; 14</span>
</span></code></pre></td></tr></table></div></figure>


<p>Yes:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">length</span> <span class="o">=</span> <span class="o">[</span><span class="s2">&quot;milu&quot;</span><span class="p">,</span> <span class="s2">&quot;rantanplan&quot;</span><span class="o">].</span><span class="n">inject</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">accumulator</span><span class="p">,</span> <span class="n">dog_name</span><span class="o">|</span>
</span><span class='line'>  <span class="n">accumulator</span> <span class="o">+</span> <span class="n">dog_name</span><span class="o">.</span><span class="n">length</span>
</span><span class='line'><span class="k">end</span> <span class="c1"># =&gt; 14</span>
</span></code></pre></td></tr></table></div></figure>


<p>在这个特殊情况下，当累积器与元素之间有操作进行时，我们不需要区块，只要将操作传给符号即可。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">length</span> <span class="o">=</span> <span class="o">[</span><span class="s2">&quot;milu&quot;</span><span class="p">,</span> <span class="s2">&quot;rantanplan&quot;</span><span class="o">].</span><span class="n">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:length</span><span class="p">)</span><span class="o">.</span><span class="n">inject</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="ss">:+</span><span class="p">)</span> <span class="c1"># 14</span>
</span></code></pre></td></tr></table></div></figure>


<h4>empty + each + accumulate + push -> scan</h4>

<p>想像一下，你不仅想要折叠(fold)的结果，也想要过程中产生的部分数值。用命令式编程风格，你可能会这么写：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">lengths</span> <span class="o">=</span> <span class="o">[]</span>
</span><span class='line'><span class="n">total_length</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'><span class="o">[</span><span class="s2">&quot;milu&quot;</span><span class="p">,</span> <span class="s2">&quot;rantanplan&quot;</span><span class="o">].</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">dog_name</span><span class="o">|</span>
</span><span class='line'>  <span class="n">lengths</span> <span class="o">&lt;&lt;</span> <span class="n">total_length</span>
</span><span class='line'>  <span class="n">total_length</span> <span class="o">+=</span> <span class="n">dog_name</span><span class="o">.</span><span class="n">length</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'><span class="n">lengths</span> <span class="c1"># [0, 4, 14]</span>
</span></code></pre></td></tr></table></div></figure>


<p>在函数式的世界里，Haskell 称之为 <a href="http://zvon.org/other/haskell/Outputprelude/scanl_f.html">scan</a>, C++ 称之为 <a href="http://www.cplusplus.com/reference/std/numeric/partial_sum/">partial_sum</a>, Clojure 称之为 <a href="http://clojuredocs.org/clojure_core/clojure.core/reductions">reductions</a>。</p>

<p>令人诧异的是，Ruby 居然没有这样的函数！让我们自己写一个。这个怎么样：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">lengths</span> <span class="o">=</span> <span class="o">[</span><span class="s2">&quot;milu&quot;</span><span class="p">,</span> <span class="s2">&quot;rantanplan&quot;</span><span class="o">].</span><span class="n">partial_inject</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">dog_name</span><span class="o">|</span>
</span><span class='line'>  <span class="n">dog_name</span><span class="o">.</span><span class="n">length</span>
</span><span class='line'><span class="k">end</span> <span class="c1"># [0, 4, 14]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Enumerable#partial_inject 可以这么实现：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">Enumerable</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">partial_inject</span><span class="p">(</span><span class="n">initial_value</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
</span><span class='line'>    <span class="nb">self</span><span class="o">.</span><span class="n">inject</span><span class="p">(</span><span class="o">[</span><span class="n">initial_value</span><span class="p">,</span> <span class="o">[</span><span class="n">initial_value</span><span class="o">]]</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="p">(</span><span class="n">accumulated</span><span class="p">,</span> <span class="n">output</span><span class="p">),</span> <span class="n">element</span><span class="o">|</span>
</span><span class='line'>      <span class="n">new_value</span> <span class="o">=</span> <span class="k">yield</span><span class="p">(</span><span class="n">accumulated</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span>
</span><span class='line'>      <span class="o">[</span><span class="n">new_value</span><span class="p">,</span> <span class="n">output</span> <span class="o">&lt;&lt;</span> <span class="n">new_value</span><span class="o">]</span>
</span><span class='line'>    <span class="k">end</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>实作的细节不重要，重要的是，当认出一个有趣的模式可以被抽象化时，我们将其写在另一个函式库，撰写文档，反覆测试。现在只要让实际的需求去完善你的扩充即可。</p>

<h4>initial assign + conditional assign + conditional assign + &#8230;</h4>

<p>这样的程序我们常常看到：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">name</span> <span class="o">=</span> <span class="n">obj1</span><span class="o">.</span><span class="n">name</span>
</span><span class='line'><span class="nb">name</span> <span class="o">=</span> <span class="n">obj2</span><span class="o">.</span><span class="n">name</span> <span class="k">if</span> <span class="o">!</span><span class="nb">name</span>
</span><span class='line'><span class="nb">name</span> <span class="o">=</span> <span class="n">ask_name</span> <span class="k">if</span> <span class="o">!</span><span class="nb">name</span>
</span></code></pre></td></tr></table></div></figure>


<p>在此时你应该觉得这样的代码使你很不自在（一个变量一下是这个值，一下是这个；变量名 <code>name</code> 到处都是…等）。函数式的方式更简短，也更简洁：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">name</span> <span class="o">=</span> <span class="n">obj1</span><span class="o">.</span><span class="n">name</span> <span class="o">||</span> <span class="n">obj2</span><span class="o">.</span><span class="n">name</span> <span class="o">||</span> <span class="n">ask_name</span>
</span></code></pre></td></tr></table></div></figure>


<p>另一个有更复杂条件的例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">get_best_object</span><span class="p">(</span><span class="n">obj1</span><span class="p">,</span> <span class="n">obj2</span><span class="p">,</span> <span class="n">obj3</span><span class="p">)</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">obj1</span> <span class="k">if</span> <span class="n">obj1</span><span class="o">.</span><span class="n">price</span> <span class="o">&lt;</span> <span class="mi">20</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">obj2</span> <span class="k">if</span> <span class="n">obj2</span><span class="o">.</span><span class="n">quality</span> <span class="o">&gt;</span> <span class="mi">3</span>
</span><span class='line'>  <span class="n">obj3</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以写成像是这样的一个表达式：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">get_best_object</span><span class="p">(</span><span class="n">obj1</span><span class="p">,</span> <span class="n">obj2</span><span class="p">,</span> <span class="n">obj3</span><span class="p">)</span>
</span><span class='line'>  <span class="k">if</span> <span class="n">obj1</span><span class="o">.</span><span class="n">price</span> <span class="o">&lt;</span> <span class="mi">20</span>
</span><span class='line'>    <span class="n">obj1</span>
</span><span class='line'>  <span class="k">elsif</span> <span class="n">obj2</span><span class="o">.</span><span class="n">quality</span> <span class="o">&gt;</span> <span class="mi">3</span>
</span><span class='line'>    <span class="n">obj2</span>
</span><span class='line'>  <span class="k">else</span>
</span><span class='line'>    <span class="n">obj3</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>确实有一点啰嗦，但逻辑比一堆行内 <code>if/unless</code> 来得清楚。经验法则告诉我们，仅在你确定会用到副作用时，使用行内条件式，而不是在变量赋值或返回的场合使用：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">country</span> <span class="o">=</span> <span class="no">Country</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span><span class='line'><span class="n">country</span><span class="o">.</span><span class="n">invade</span> <span class="k">if</span> <span class="n">country</span><span class="o">.</span><span class="n">has_oil?</span>
</span><span class='line'><span class="c1"># more code here</span>
</span></code></pre></td></tr></table></div></figure>


<h4>如何从 enumerable 创造一个 hash</h4>

<p>Vanilla Ruby 没有从 Enumerable 转到 Hash 的直接对应（本人认为是一个令人遗憾的缺陷）。这也是为什么新手持续写出下面这个糟糕的模式(而你怎么能责怪他们呢？唉！）：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">hash</span> <span class="o">=</span> <span class="p">{}</span>
</span><span class='line'><span class="n">input</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">item</span><span class="o">|</span>
</span><span class='line'>  <span class="nb">hash</span><span class="o">[</span><span class="n">item</span><span class="o">]</span> <span class="o">=</span> <span class="n">process</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'><span class="nb">hash</span>
</span></code></pre></td></tr></table></div></figure>


<p>这真的非常可怕！阿～～～！但手边有没有更好的办法呢？过去 Hash 构造子需要一个有着连续键值对的 flatten 集合 （阿，用 flatten 数组来描述映射？Lisp 曾这么做，但还是很丑陋）。幸运的是，Ruby 的最新版本也接受键值对，这样更有意义（作为 <code>hash.to_a</code> 的逆操作），现在你可以这么写：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">Hash</span><span class="o">[</span><span class="n">input</span><span class="o">.</span><span class="n">map</span> <span class="k">do</span> <span class="o">|</span><span class="n">item</span><span class="o">|</span>
</span><span class='line'>  <span class="o">[</span><span class="n">item</span><span class="p">,</span> <span class="n">process</span><span class="p">(</span><span class="n">item</span><span class="p">)</span><span class="o">]</span>
</span><span class='line'><span class="k">end</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>不赖嘛，但这打破了平常的撰写顺序。在 Ruby 我们期望从左向右写，给对象调用方法。而“好的”函数式方式是使用 <code>inject</code>：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">input</span><span class="o">.</span><span class="n">inject</span><span class="p">({})</span> <span class="k">do</span> <span class="o">|</span><span class="nb">hash</span><span class="p">,</span> <span class="n">item</span><span class="o">|</span>
</span><span class='line'>  <span class="nb">hash</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">item</span> <span class="o">=&gt;</span> <span class="n">process</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们都同意这还是很啰嗦，所以我们最好将它放在 Enumerable 模块，<a href="http://rubyworks.github.com/facets/">Facets</a> 正是这么干的。它称之为 Enumerable#mash：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">Enumerable</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">mash</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
</span><span class='line'>    <span class="nb">self</span><span class="o">.</span><span class="n">inject</span><span class="p">({})</span> <span class="k">do</span> <span class="o">|</span><span class="n">output</span><span class="p">,</span> <span class="n">item</span><span class="o">|</span>
</span><span class='line'>      <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="nb">block_given?</span> <span class="p">?</span> <span class="k">yield</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="p">:</span> <span class="n">item</span>
</span><span class='line'>      <span class="n">output</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">key</span> <span class="o">=&gt;</span> <span class="n">value</span><span class="p">)</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="o">[</span><span class="s2">&quot;functional&quot;</span><span class="p">,</span> <span class="s2">&quot;programming&quot;</span><span class="p">,</span> <span class="s2">&quot;rules&quot;</span><span class="o">].</span><span class="n">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">s</span><span class="o">|</span> <span class="o">[</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">length</span><span class="o">]</span> <span class="p">}</span><span class="o">.</span><span class="n">mash</span>
</span><span class='line'><span class="c1"># {&quot;functional&quot;=&gt;10, &quot;programming&quot;=&gt;11, &quot;rules&quot;=&gt;5}</span>
</span></code></pre></td></tr></table></div></figure>


<p>或使用 <code>mash</code> 及 选择性区块来一步完成：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="o">[</span><span class="s2">&quot;functional&quot;</span><span class="p">,</span> <span class="s2">&quot;programming&quot;</span><span class="p">,</span> <span class="s2">&quot;rules&quot;</span><span class="o">].</span><span class="n">mash</span> <span class="p">{</span> <span class="o">|</span><span class="n">s</span><span class="o">|</span> <span class="o">[</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">length</span><span class="o">]</span> <span class="p">}</span>
</span><span class='line'><span class="c1"># {&quot;functional&quot;=&gt;10, &quot;programming&quot;=&gt;11, &quot;rules&quot;=&gt;5}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>面向对象与函数式编程</h3>

<p><a href="http://www.sics.se/~joe/">Joe Armstrong</a> (Erlang 发明人) 在 “Coders At work” 谈论过面向对象编程的重用性：</p>

<p>“我认为缺少重用性是面向对象语言造成的，而不是函数式语言。面向对象语言的问题是，它们带着语言执行环境的所有隐含资讯四处乱窜。你想要的是香蕉，但看到的却是香蕉拿在大猩猩手里，而大猩猩的后面是整个丛林”</p>

<p>公平点说，我的看法是这不是面向对象编程的本质问题。你可以写出函数式的面向对象程序，但确定的是：</p>

<ul>
<li>典型的 OOP 倾向强调改变对象的状态。</li>
<li>典型的 OOP 倾向层与层之间紧密的耦合。</li>
<li>典型的 OOP 将同一性(identity)与状态的概念搞混了。</li>
<li>数据与代码的混合物，导致了概念与实际的问题产生。</li>
</ul>


<p><a href="https://twitter.com/richhickey">Rich Hickey</a>，Clojure 的发明人（一个给 JVM 用的函数式 Lisp 方言），在这场<a href="http://www.infoq.com/presentations/Value-Identity-State-Rich-Hickey">出色的演讲</a>里谈论了状态、数值以及同一性。</p>

<h3>万物皆表达式</h3>

<p>可以这么写：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">if</span> <span class="n">found_dog</span> <span class="o">==</span> <span class="n">our_dog</span>
</span><span class='line'>  <span class="nb">name</span> <span class="o">=</span> <span class="n">found_dog</span><span class="o">.</span><span class="n">name</span>
</span><span class='line'>  <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;We found our dog </span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">!&quot;</span>
</span><span class='line'><span class="k">else</span>
</span><span class='line'>  <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;No luck&quot;</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>然而，控制结构（<code>if</code>, <code>while</code>, <code>case</code> 等）也返回表达式，所以只要这样写就好：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">message</span> <span class="o">=</span> <span class="k">if</span> <span class="n">found_dog</span> <span class="o">==</span> <span class="n">my_dog</span>
</span><span class='line'>  <span class="nb">name</span> <span class="o">=</span> <span class="n">found_dog</span><span class="o">.</span><span class="n">name</span>
</span><span class='line'>  <span class="s2">&quot;We found our dog </span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">!&quot;</span>
</span><span class='line'><span class="k">else</span>
</span><span class='line'>  <span class="s2">&quot;No luck&quot;</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>这样子我们不用重复变量名 <code>message</code>，企图也更明显：当有段长的程序（用了一堆我们不在乎的变量），我们可以专注在程序在干什么（返回信息）。再强调一次，我们在缩小程序的作用域。</p>

<p>另一个函数式程序的好处是，表达式可以用来构造数据：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="ss">:name</span> <span class="o">=&gt;</span> <span class="s2">&quot;M.Cassatt&quot;</span><span class="p">,</span>
</span><span class='line'>  <span class="ss">:paintings</span> <span class="o">=&gt;</span> <span class="n">paintings</span><span class="o">.</span><span class="n">select</span> <span class="p">{</span> <span class="o">|</span><span class="nb">p</span><span class="o">|</span> <span class="nb">p</span><span class="o">.</span><span class="n">author</span> <span class="o">==</span> <span class="s2">&quot;M.Cassatt&quot;</span> <span class="p">},</span>
</span><span class='line'>  <span class="ss">:birth</span> <span class="o">=&gt;</span> <span class="n">painters</span><span class="o">.</span><span class="n">detect</span> <span class="p">{</span> <span class="o">|</span><span class="nb">p</span><span class="o">|</span> <span class="nb">p</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;M.Cassatt&quot;</span> <span class="p">}</span><span class="o">.</span><span class="n">birth</span><span class="o">.</span><span class="n">year</span><span class="p">,</span>
</span><span class='line'>  <span class="o">.</span><span class="n">.</span><span class="o">.</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>递归</h3>

<p>纯函数式语言没有隐含的状态，大量利用了递归。为了避免栈溢出，函数式使用一种称为尾递归优化(TCO)的机制。Ruby 1.9 有实作这种机制，但缺省没有打开。要是你希望你的程序，在哪都可以动的话，就不要使用它。</p>

<p>但是某些情况下，递归仍然是很有用的，即便是每次递归时都创建新的栈。注意！某些递归的用途可以用 foldings 来实现(像 Enumerable#inject)。</p>

<p>在 MRI-1.9 启用 TCO：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="ss">RubyVM</span><span class="p">:</span><span class="ss">:InstructionSequence</span><span class="o">.</span><span class="n">compile_option</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>  <span class="ss">:tailcall_optimization</span> <span class="o">=&gt;</span> <span class="kp">true</span><span class="p">,</span>
</span><span class='line'>  <span class="ss">:trace_instruction</span> <span class="o">=&gt;</span> <span class="kp">false</span><span class="p">,</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>简单例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">Math</span>
</span><span class='line'>  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">factorial_tco</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">acc</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</span><span class='line'>    <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">?</span> <span class="n">acc</span> <span class="p">:</span> <span class="n">factorial_tco</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">*</span><span class="n">acc</span><span class="p">)</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>在递归深度不太可能很深的情况下，你仍可以使用：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">Node</span>
</span><span class='line'>  <span class="n">has_many</span> <span class="ss">:children</span><span class="p">,</span> <span class="ss">:class_name</span> <span class="o">=&gt;</span> <span class="s2">&quot;Node&quot;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">all_children</span>
</span><span class='line'>    <span class="nb">self</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">flat_map</span> <span class="k">do</span> <span class="o">|</span><span class="n">child</span><span class="o">|</span>
</span><span class='line'>      <span class="o">[</span><span class="n">child</span><span class="o">]</span> <span class="o">+</span> <span class="n">child</span><span class="o">.</span><span class="n">all_children</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<h3>惰性枚举器</h3>

<p>惰性求值延迟了表达式的求值，在真正需要时才会求值。与 eager evaluation 相反，eager evaluation 当一个变量被赋值时、函数被调用时…甚至根本没用到变量等状况，都立马对表达式求值，惰性不是函数式编程的必需品，但这是个符合函数式范式的好策略（Haskell 大概是最佳的例子，弥漫着懒惰的语言）。</p>

<p>Ruby 所采用的基本上是 eager evaluation（虽然许多其它的语言，在条件还没满足前不对表达式求值，以及短路布尔运算 <code>&amp;&amp;</code>, <code>||</code> 等）。然而，与任何内置高阶函数的语言一样，延迟求值是隐性支持的，因为程序员自己决定区块何时被调用。</p>

<p>Enumerators 同样 从 Ruby 1.9 开始支持(1.8 请用 backports)，它们提供了一个简单的介面来定义惰性 enumerables。经典的例子是构造一个枚举器，返回所有的自然数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">require</span> <span class="s1">&#39;backports&#39;</span> <span class="c1"># 1.8 才需要</span>
</span><span class='line'><span class="n">natural_numbers</span> <span class="o">=</span> <span class="no">Enumerator</span><span class="o">.</span><span class="n">new</span> <span class="k">do</span> <span class="o">|</span><span class="n">yielder</span><span class="o">|</span>
</span><span class='line'>  <span class="n">number</span> <span class="o">=</span> <span class="mi">1</span>
</span><span class='line'>  <span class="kp">loop</span> <span class="k">do</span>
</span><span class='line'>    <span class="n">yielder</span><span class="o">.</span><span class="n">yield</span> <span class="n">number</span>
</span><span class='line'>    <span class="n">number</span> <span class="o">+=</span> <span class="mi">1</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以用更函数式的精神改写：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">natural_numbers</span> <span class="o">=</span> <span class="no">Enumerator</span><span class="o">.</span><span class="n">new</span> <span class="k">do</span> <span class="o">|</span><span class="n">yielder</span><span class="o">|</span>
</span><span class='line'>  <span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="mi">1</span><span class="o">.</span><span class="mi">0</span><span class="o">/</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">number</span><span class="o">|</span>
</span><span class='line'>    <span class="n">yielder</span><span class="o">.</span><span class="n">yield</span> <span class="n">number</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">natural_numbers</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</span><span class='line'><span class="c1"># [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span>
</span></code></pre></td></tr></table></div></figure>


<p>现在，试试给 <code>natural_numbers</code> 做 <code>map</code>，发生什么事？它不会停止。标准的 enumerable 方法 (<code>map</code>, <code>select</code> 等）返回一个数组，所以在输入流是无穷大时，无法正常工作。让我们扩展 Enumerator 类别，比如加入这个惰性的 Enumerator#map：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">Enumerator</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">map</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
</span><span class='line'>    <span class="no">Enumerator</span><span class="o">.</span><span class="n">new</span> <span class="k">do</span> <span class="o">|</span><span class="n">yielder</span><span class="o">|</span>
</span><span class='line'>      <span class="nb">self</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">value</span><span class="o">|</span>
</span><span class='line'>        <span class="n">yielder</span><span class="o">.</span><span class="n">yield</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
</span><span class='line'>      <span class="k">end</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>现在我们可以给所有自然数的流做 <code>map</code> 了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">natural_numbers</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="p">}</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</span><span class='line'><span class="c1"># [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]</span>
</span></code></pre></td></tr></table></div></figure>


<p>枚举器是用来构造惰性行为的区块的好东西，但你可以使用用懒惰风格，实作了所有 enumerable 方法的函式库：</p>

<p>https://github.com/yhara/enumerable-lazy</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">require</span> <span class="s1">&#39;enumerable/lazy&#39;</span>
</span><span class='line'><span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="mi">1</span><span class="o">.</span><span class="mi">0</span><span class="o">/</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">lazy</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="p">}</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">to_a</span>
</span><span class='line'><span class="c1"># [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]</span>
</span></code></pre></td></tr></table></div></figure>


<h4>惰性求值的好处</h4>

<ol>
<li><p>显而易见的好处: 无需在不必要的情况下，构造、储存完整的结构（也许，可以更有效率的使用 CPU 及内存）</p></li>
<li><p>不太显而易见的好处: 惰性求值使写程序不需要了解超出你所需的范围。让我们看一个例子：你写了某种解题工具，可以提供无数种解法，但在某个时候，你只想要前十种解法。你可能会这么写：</p></li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">solver</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="ss">:max</span> <span class="o">=&gt;</span> <span class="mi">10</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>当你与惰性结构一起工作时，不需要说什么时候该结束。调用者自己会决定他需要多少值。代码变得更简单，责任归属到对的地方，也就是调用者：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">solver</span><span class="p">(</span><span class="n">input</span><span class="p">)</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h3>一个实际的例子</h3>

<p>练习：“前十个平方可被五整除的自然数的和是多少？”</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">Integer</span><span class="o">::</span><span class="n">natural</span><span class="o">.</span><span class="n">select</span> <span class="p">{</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">%</span> <span class="mi">5</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">}</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">inject</span><span class="p">(</span><span class="ss">:+</span><span class="p">)</span> <span class="c1">#=&gt; 275</span>
</span></code></pre></td></tr></table></div></figure>


<p>让我们跟等价的命令式版本来比较：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">n</span><span class="p">,</span> <span class="n">num_elements</span><span class="p">,</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
</span><span class='line'><span class="k">while</span> <span class="n">num_elements</span> <span class="o">&lt;</span> <span class="mi">10</span>
</span><span class='line'>  <span class="k">if</span> <span class="n">n</span><span class="o">**</span><span class="mi">2</span> <span class="o">%</span> <span class="mi">5</span> <span class="o">==</span> <span class="mi">0</span>
</span><span class='line'>    <span class="n">sum</span> <span class="o">+=</span> <span class="n">n</span>
</span><span class='line'>    <span class="n">num_elements</span> <span class="o">+=</span> <span class="mi">1</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>  <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'><span class="n">sum</span> <span class="c1">#=&gt; 275</span>
</span></code></pre></td></tr></table></div></figure>


<p>我希望这个例子展示了这个文档里讨论的函数式编程的优点：</p>

<ol>
<li><p>更简洁: 你会撰写更少的代码。函数式程序处理的是表达式，而表达式可以连锁起来；命令式程序处理的是变量的改动（叙述式），而这不能连锁。</p></li>
<li><p>更抽象: 你可以争论我们使用 <code>select</code>, <code>inject</code>…等等，来隐藏了一大堆代码，我很高兴你这么说，因为我们正是这么干的。将通用的、可重用的代码隐藏起来，这是所有编程的重点 –– 但函数式编程特别是关于如何撰写抽象。感到开心不是因为写了更少的代码，而是因为藉由认出可重用的模式，简化了代码的复杂性。</p></li>
<li><p>更有声明式的味道: 看看命令式的版本，第一眼看起来是一坨无用的代码 –– 没有注解的话 –– 它会做什么你完全没有概念。你可能会说：“好吧，从这里开始读，草草记下 <code>n</code> 与 <code>sum</code> 的值，进入某个循环，看看 <code>n</code> 与 <code>sum</code> 的值如何变化，看看最后一次迭代的情形” 等等。函数式版本另一方面是自我解释的，函数式版本描述、声明它在干的事，而不是如何干这件事。</p></li>
</ol>


<p>“函数式编程就像是将你的问题叙述给数学家一样。命令式编程像是给白痴下指令” (arcus 在 Freenode #scheme 频道所说）</p>

<h3>结论</h3>

<p>更好的理解函数式编程的原理，帮助我们写出更清晰、重用性更高并更简洁的代码。Ruby 基本上是一个命令式语言，但它也有很大的函数式能力，明白什么时候用，及如何用（以及何时不该用）这些能力。将这句话当成你的座右铭吧 “状态是万恶的根源，尽可能避免它。”</p>

<h3>展示</h3>

<p>Workshop at <a href="http://conferenciarails.org/">Conferencia Rails 2011</a>: <a href="http://public.arnau-sanchez.com/ruby-functional/">Functional Programming with Ruby</a> <a href="http://www.slideshare.net/tokland/functional-programming-with-ruby-9975242">(slideshare)</a></p>

<h3>延伸阅读</h3>

<p>http://en.wikipedia.org/wiki/Functional_programming</p>

<p>https://github.com/JuanitoFatas/Ruby-Functional-Programming/blob/master/RADME-zhCN.md</p>

<p>http://www.defmacro.org/ramblings/fp.html <strong><a href="http://t.cn/zYaCDw7">译文</a></strong></p>

<p>http://www.cse.chalmers.se/~rjmh/Papers/whyfp.html</p>

<p>http://www.khelll.com/blog/ruby/ruby-and-functional-programming/</p>

<p>http://www.bestechvideos.com/2008/11/30/rubyconf-2008-better-ruby-through-functional-programming</p>

<p>http://channel9.msdn.com/Blogs/pdc2008/TL11</p>

<p>http://www.infoq.com/presentations/Value-Identity-State-Rich-Hickey</p>

<h2>授权</h2>

<p>This document is licensed under the CC-By 3.0 License, which encourages you to share these documents. See http://creativecommons.org/licenses/by/3.0/ for more details.</p>

<p><img alt="CC-By 3.0 License http://creativecommons.org/licenses/by/3.0/" style="border-width:0" src="http://i.creativecommons.org/l/by/3.0/88x31.png" /></p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Peng Feixiang</span></span>

      








  


<time datetime="2013-05-20T17:20:00+08:00" pubdate data-updated="true">May 20<span>th</span>, 2013</time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/ruby/'>ruby</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  <a href="http://twitter.com/share" class="twitter-share-button" data-url="http://pengfx.github.io/blog/2013/05/20/ruby-functional-programming/" data-via="" data-counturl="http://pengfx.github.io/blog/2013/05/20/ruby-functional-programming/" >Tweet</a>
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2013/05/06/set-local-octopress-env/" title="Previous Post: 为已托管在github的octopress配置本地环境">&laquo; 为已托管在github的octopress配置本地环境</a>
      
      
    </p>
  </footer>
</article>

</div>

<aside class="sidebar">
  
    <section>
  <ul id="recent_posts">
      <li class="post">
      <a href="http://pengfx.github.io" alt="Home"><img src="/images/Home.png"></a>
      <a href="http://pengfx.github.io/archives/" alt="Archives"><img src="/images/Calendar.png"></a>
      
      <a href="http://pengfx.github.io/atom.xml" alt="subscribe feed"><img src="/images/rss.png"></a>
      </li>
  </ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2013/05/20/ruby-functional-programming/">Ruby 函数式编程</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/05/06/set-local-octopress-env/">为已托管在github的octopress配置本地环境</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/05/06/draft-mccann-dmm-flatarch-00/">draft-mccann-dmm-flatarch-00</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/05/06/draft-ma-dmm-romip-00/">draft-ma-dmm-romip-00</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/05/06/draft-ma-dmm-armip-00/">draft-ma-dmm-armip-00</a>
      </li>
    
  </ul>
</section>





  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - Peng Feixiang -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
