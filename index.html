
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>My Blog</title>
  <meta name="author" content="Peng Feixiang">

  
  <meta name="description" content="Ruby 函数式编程 by Arnau Sanchez 本文档翻译自 Arnau Sanchez (tokland)所编译的这份文档 RubyFunctionalProgramming。 同时也有日文版本。 目录 简介
理论部分
Ruby的函数式编程 不要更新变量
用 Blocks 作为高阶函数 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://pengfx.github.io/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="My Blog" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:pengfx.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
    <li><a href="/">
        <span class="blue_light">
            My Blog
        </span>
       
           <span class="blue_dark">
             Hello
           </span>
       
    </a></li>
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About me</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/05/20/ruby-functional-programming/">Ruby 函数式编程</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-05-20T17:20:00+08:00" pubdate data-updated="true">May 20<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>Ruby 函数式编程 by Arnau Sanchez</h1>

<p>本文档翻译自 Arnau Sanchez (tokland)所编译的这份文档 <a href="http://code.google.com/p/tokland/wiki/RubyFunctionalProgramming">RubyFunctionalProgramming</a>。</p>

<p>同时也有<a href="http://www.h6.dion.ne.jp/~machan/misc/FPwithRuby.html">日文版本</a>。</p>

<h2>目录</h2>

<ul>
<li><a href="#-1">简介</a></li>
<li><a href="#-2">理论部分</a></li>
<li><a href="#ruby">Ruby的函数式编程</a>

<ul>
<li><a href="#-3">不要更新变量</a></li>
<li><a href="#-blocks-">用 Blocks 作为高阶函数</a></li>
<li><a href="#-6">面向对象与函数式编程</a></li>
<li><a href="#-7">万物皆表达式</a></li>
<li><a href="#-8">递归</a></li>
<li><a href="#-9">惰性枚举器</a></li>
<li><a href="#-11">一个实际的例子</a></li>
</ul>
</li>
<li><a href="#-12">结论</a></li>
<li><a href="#-13">展示</a></li>
<li><a href="#-14">延伸阅读</a></li>
</ul>


<h2>简介</h2>

<blockquote><p>命令式编程比较牛吗？
不！不！不！只是比较快，比较简单，比较诱人而已。</p></blockquote>

<pre><code>x = x + 1
</code></pre>

<p>在以前上小学的美好回忆里，我们可能都曾对上面这个式子感到困惑。这个 <code>x</code> 到底是什么呢？为什么加了一之后，<code>x</code> 仍然还是 <code>x</code>。</p>

<p>不知道为什么，我们就开始写程序了，也就不在乎这是为什么了。心想：“嗯”，“这不是什么大问题，编程就是事情做完最重要，没有必要去挑剔数学的纯粹性 （让大学里的大胡子教授们去烦恼就好）” 。但我们错了，也因此付出极高的代价，只因我们不了解它。</p>

<h2>理论部分</h2>

<p><a href="http://en.wikipedia.org/wiki/Functional_programming">维基百科</a>的解释：“函数式编程是一种写程序的范式，将计算视为对数学函数的求值，并避免使用状态及可变的数据” 换句话说，函数式编程提倡没有副作用的代码，不改变变量的值。这与命令式编程相反，命令式编程强调改变状态。</p>

<p>令人惊讶的是，函数式编程就这样而已。那…有什么好处呢？</p>

<ul>
<li><p>更简洁的代码：“变量”一旦定义之后就不再改动，所以我们不需要追踪变量的状态，就可以理解一个函数、方法、类别、甚至是整个项目是怎么工作的。</p></li>
<li><p>引用透明：表达式可以用本身的值换掉。如果我们用同样的参数调用一个函数，我们确信输出会是一样的结果（没有其它的状态可改变它的值）。这也是为什么爱因斯坦说：“重复做一样的事却期望不同的结果”是疯狂的理由。</p></li>
</ul>


<p>引用透明打开了前往某些美妙事物的大门</p>

<ul>
<li><p>并行化：如果调用函数是各自独立的，则他们可以在不同的进程甚至是机器里执行，而不会有竞态条件的问题。“平常” 写并发程序讨厌的细节（锁、semaphore…等）在函数式编程里面通通消失不见了。</p></li>
<li><p>记忆化：由于函数调用的结果等于它的返回值，我们可以把这些值缓存起来。</p></li>
<li><p>模块化：代码里不存有状态，所以我们可以将项目用小的黑箱连结起来，函数式编程提倡自底向上的编程风格。</p></li>
<li><p>容易调试：函数彼此互相隔离，只依赖输入与输出，所以很容易调试。</p></li>
</ul>


<h2>Ruby的函数式编程</h2>

<p>一切都是这么美好，但怎样才能将函数式编程，应用到每天写 Ruby（Ruby 不是个函数式语言）的程序开发里呢？函数式编程广义来说，是一种风格，可以用在任何语言。当然啦，用在特别为这种范式打造的语言里显得更自然，但某种程度上来说，可以应用到任何语言。</p>

<p>让我们先理清这一点：本文没有要提倡古怪的风格，比如仅仅为了要延续理论函数式编程的纯粹性所带来的古怪风格。反之，我想说的重点是，我们应该 <strong>当可以提升代码的品质的时候，才使用函数式编程</strong> ，不然这只不过是个糟糕的解决办法。</p>

<h3>不要更新变量</h3>

<p>别更新它们，创造新的变量。</p>

<h4>不要对数组或字串做 <code>append</code></h4>

<p>No:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">indexes</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="o">]</span>
</span><span class='line'><span class="n">indexes</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span>
</span><span class='line'><span class="n">indexes</span> <span class="c1"># [1, 2, 3, 4]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Yes：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">indexes</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="o">]</span>
</span><span class='line'><span class="n">all_indexes</span> <span class="o">=</span> <span class="n">indexes</span> <span class="o">+</span> <span class="o">[</span><span class="mi">4</span><span class="o">]</span> <span class="c1"># [1, 2, 3, 4]</span>
</span></code></pre></td></tr></table></div></figure>


<h4>不要更新 hash</h4>

<p>No:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">hash</span> <span class="o">=</span> <span class="p">{</span><span class="ss">:a</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="ss">:b</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="p">}</span>
</span><span class='line'><span class="nb">hash</span><span class="o">[</span><span class="ss">:c</span><span class="o">]</span> <span class="o">=</span> <span class="mi">3</span>
</span><span class='line'><span class="nb">hash</span>
</span></code></pre></td></tr></table></div></figure>


<p>Yes:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">hash</span> <span class="o">=</span> <span class="p">{</span><span class="ss">:a</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="ss">:b</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="p">}</span>
</span><span class='line'><span class="n">new_hash</span> <span class="o">=</span> <span class="nb">hash</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="ss">:c</span> <span class="o">=&gt;</span> <span class="mi">3</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h4>牵扯到内存位置的地方，不要使用破坏性方法。</h4>

<p>No:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">string</span> <span class="o">=</span> <span class="s2">&quot;hello&quot;</span>
</span><span class='line'><span class="n">string</span><span class="o">.</span><span class="n">gsub!</span><span class="p">(</span><span class="sr">/l/</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">)</span>
</span><span class='line'><span class="n">string</span> <span class="c1"># &quot;hezzo&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Yes:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">string</span> <span class="o">=</span> <span class="s2">&quot;hello&quot;</span>
</span><span class='line'><span class="n">new_string</span> <span class="o">=</span>  <span class="n">string</span><span class="o">.</span><span class="n">gsub</span><span class="p">(</span><span class="sr">/l/</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">)</span> <span class="c1"># &quot;hezzo&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<h4>如何累积值</h4>

<p>No:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">output</span> <span class="o">=</span> <span class="o">[]</span>
</span><span class='line'><span class="n">output</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span>
</span><span class='line'><span class="n">output</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span> <span class="k">if</span> <span class="n">i_have_to_add_two</span>
</span><span class='line'><span class="n">output</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span>
</span></code></pre></td></tr></table></div></figure>


<p>Yes:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">output</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span> <span class="k">if</span> <span class="n">i_have_to_add_two</span><span class="p">),</span> <span class="mi">3</span><span class="o">].</span><span class="n">compact</span>
</span></code></pre></td></tr></table></div></figure>


<h3>用 Blocks 作为高阶函数</h3>

<p>如果一个语言要搞函数式，会需要高阶函数。高阶函数是什么？函数可以接受别的函数作为参数，并可以返回函数，就这么简单。</p>

<p>Ruby (与 Smalltalk 还有其它语言）在这个方面上非常特别，语言本身就内置这个功能： <strong>blocks</strong> 区块。区块是一段匿名的代码，你可以随意的传来传去或是执行它。让我们看区块的典型用途，来构造函数式编程的构造子。</p>

<h4>init-empty + each + push = map</h4>

<p>No:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">dogs</span> <span class="o">=</span> <span class="o">[]</span>
</span><span class='line'><span class="o">[</span><span class="s2">&quot;milu&quot;</span><span class="p">,</span> <span class="s2">&quot;rantanplan&quot;</span><span class="o">].</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="nb">name</span><span class="o">|</span>
</span><span class='line'>  <span class="n">dogs</span> <span class="o">&lt;&lt;</span> <span class="nb">name</span><span class="o">.</span><span class="n">upcase</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'><span class="n">dogs</span> <span class="c1"># =&gt; [&quot;MILU&quot;, &quot;RANTANPLAN&quot;]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Yes:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">dogs</span> <span class="o">=</span> <span class="o">[</span><span class="s2">&quot;milu&quot;</span><span class="p">,</span> <span class="s2">&quot;rantanplan&quot;</span><span class="o">].</span><span class="n">map</span> <span class="k">do</span> <span class="o">|</span><span class="nb">name</span><span class="o">|</span>
</span><span class='line'>  <span class="nb">name</span><span class="o">.</span><span class="n">upcase</span>
</span><span class='line'><span class="k">end</span> <span class="c1"># =&gt; [&quot;MILU&quot;, &quot;RANTANPLAN&quot;]</span>
</span></code></pre></td></tr></table></div></figure>


<h4>init-empty + each + conditional push -> select/reject</h4>

<p>No:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">dogs</span> <span class="o">=</span> <span class="o">[]</span>
</span><span class='line'><span class="o">[</span><span class="s2">&quot;milu&quot;</span><span class="p">,</span> <span class="s2">&quot;rantanplan&quot;</span><span class="o">].</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="nb">name</span><span class="o">|</span>
</span><span class='line'>  <span class="k">if</span> <span class="nb">name</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">4</span>
</span><span class='line'>    <span class="n">dogs</span> <span class="o">&lt;&lt;</span> <span class="nb">name</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'><span class="n">dogs</span> <span class="c1"># =&gt; [&quot;milu&quot;]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Yes:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">dogs</span> <span class="o">=</span> <span class="o">[</span><span class="s2">&quot;milu&quot;</span><span class="p">,</span> <span class="s2">&quot;rantanplan&quot;</span><span class="o">].</span><span class="n">select</span> <span class="k">do</span> <span class="o">|</span><span class="nb">name</span><span class="o">|</span>
</span><span class='line'>  <span class="nb">name</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">4</span>
</span><span class='line'><span class="k">end</span> <span class="c1"># =&gt; [&quot;milu&quot;]</span>
</span></code></pre></td></tr></table></div></figure>


<h4>initialize + each + accumulate -> inject</h4>

<p>No:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">length</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'><span class="o">[</span><span class="s2">&quot;milu&quot;</span><span class="p">,</span> <span class="s2">&quot;rantanplan&quot;</span><span class="o">].</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">dog_name</span><span class="o">|</span>
</span><span class='line'>  <span class="n">length</span> <span class="o">+=</span> <span class="n">dog_name</span><span class="o">.</span><span class="n">length</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'><span class="n">length</span> <span class="c1"># =&gt; 14</span>
</span></code></pre></td></tr></table></div></figure>


<p>Yes:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">length</span> <span class="o">=</span> <span class="o">[</span><span class="s2">&quot;milu&quot;</span><span class="p">,</span> <span class="s2">&quot;rantanplan&quot;</span><span class="o">].</span><span class="n">inject</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">accumulator</span><span class="p">,</span> <span class="n">dog_name</span><span class="o">|</span>
</span><span class='line'>  <span class="n">accumulator</span> <span class="o">+</span> <span class="n">dog_name</span><span class="o">.</span><span class="n">length</span>
</span><span class='line'><span class="k">end</span> <span class="c1"># =&gt; 14</span>
</span></code></pre></td></tr></table></div></figure>


<p>在这个特殊情况下，当累积器与元素之间有操作进行时，我们不需要区块，只要将操作传给符号即可。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">length</span> <span class="o">=</span> <span class="o">[</span><span class="s2">&quot;milu&quot;</span><span class="p">,</span> <span class="s2">&quot;rantanplan&quot;</span><span class="o">].</span><span class="n">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:length</span><span class="p">)</span><span class="o">.</span><span class="n">inject</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="ss">:+</span><span class="p">)</span> <span class="c1"># 14</span>
</span></code></pre></td></tr></table></div></figure>


<h4>empty + each + accumulate + push -> scan</h4>

<p>想像一下，你不仅想要折叠(fold)的结果，也想要过程中产生的部分数值。用命令式编程风格，你可能会这么写：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">lengths</span> <span class="o">=</span> <span class="o">[]</span>
</span><span class='line'><span class="n">total_length</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'><span class="o">[</span><span class="s2">&quot;milu&quot;</span><span class="p">,</span> <span class="s2">&quot;rantanplan&quot;</span><span class="o">].</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">dog_name</span><span class="o">|</span>
</span><span class='line'>  <span class="n">lengths</span> <span class="o">&lt;&lt;</span> <span class="n">total_length</span>
</span><span class='line'>  <span class="n">total_length</span> <span class="o">+=</span> <span class="n">dog_name</span><span class="o">.</span><span class="n">length</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'><span class="n">lengths</span> <span class="c1"># [0, 4, 14]</span>
</span></code></pre></td></tr></table></div></figure>


<p>在函数式的世界里，Haskell 称之为 <a href="http://zvon.org/other/haskell/Outputprelude/scanl_f.html">scan</a>, C++ 称之为 <a href="http://www.cplusplus.com/reference/std/numeric/partial_sum/">partial_sum</a>, Clojure 称之为 <a href="http://clojuredocs.org/clojure_core/clojure.core/reductions">reductions</a>。</p>

<p>令人诧异的是，Ruby 居然没有这样的函数！让我们自己写一个。这个怎么样：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">lengths</span> <span class="o">=</span> <span class="o">[</span><span class="s2">&quot;milu&quot;</span><span class="p">,</span> <span class="s2">&quot;rantanplan&quot;</span><span class="o">].</span><span class="n">partial_inject</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">dog_name</span><span class="o">|</span>
</span><span class='line'>  <span class="n">dog_name</span><span class="o">.</span><span class="n">length</span>
</span><span class='line'><span class="k">end</span> <span class="c1"># [0, 4, 14]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Enumerable#partial_inject 可以这么实现：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">Enumerable</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">partial_inject</span><span class="p">(</span><span class="n">initial_value</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
</span><span class='line'>    <span class="nb">self</span><span class="o">.</span><span class="n">inject</span><span class="p">(</span><span class="o">[</span><span class="n">initial_value</span><span class="p">,</span> <span class="o">[</span><span class="n">initial_value</span><span class="o">]]</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="p">(</span><span class="n">accumulated</span><span class="p">,</span> <span class="n">output</span><span class="p">),</span> <span class="n">element</span><span class="o">|</span>
</span><span class='line'>      <span class="n">new_value</span> <span class="o">=</span> <span class="k">yield</span><span class="p">(</span><span class="n">accumulated</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span>
</span><span class='line'>      <span class="o">[</span><span class="n">new_value</span><span class="p">,</span> <span class="n">output</span> <span class="o">&lt;&lt;</span> <span class="n">new_value</span><span class="o">]</span>
</span><span class='line'>    <span class="k">end</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>实作的细节不重要，重要的是，当认出一个有趣的模式可以被抽象化时，我们将其写在另一个函式库，撰写文档，反覆测试。现在只要让实际的需求去完善你的扩充即可。</p>

<h4>initial assign + conditional assign + conditional assign + &#8230;</h4>

<p>这样的程序我们常常看到：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">name</span> <span class="o">=</span> <span class="n">obj1</span><span class="o">.</span><span class="n">name</span>
</span><span class='line'><span class="nb">name</span> <span class="o">=</span> <span class="n">obj2</span><span class="o">.</span><span class="n">name</span> <span class="k">if</span> <span class="o">!</span><span class="nb">name</span>
</span><span class='line'><span class="nb">name</span> <span class="o">=</span> <span class="n">ask_name</span> <span class="k">if</span> <span class="o">!</span><span class="nb">name</span>
</span></code></pre></td></tr></table></div></figure>


<p>在此时你应该觉得这样的代码使你很不自在（一个变量一下是这个值，一下是这个；变量名 <code>name</code> 到处都是…等）。函数式的方式更简短，也更简洁：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">name</span> <span class="o">=</span> <span class="n">obj1</span><span class="o">.</span><span class="n">name</span> <span class="o">||</span> <span class="n">obj2</span><span class="o">.</span><span class="n">name</span> <span class="o">||</span> <span class="n">ask_name</span>
</span></code></pre></td></tr></table></div></figure>


<p>另一个有更复杂条件的例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">get_best_object</span><span class="p">(</span><span class="n">obj1</span><span class="p">,</span> <span class="n">obj2</span><span class="p">,</span> <span class="n">obj3</span><span class="p">)</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">obj1</span> <span class="k">if</span> <span class="n">obj1</span><span class="o">.</span><span class="n">price</span> <span class="o">&lt;</span> <span class="mi">20</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">obj2</span> <span class="k">if</span> <span class="n">obj2</span><span class="o">.</span><span class="n">quality</span> <span class="o">&gt;</span> <span class="mi">3</span>
</span><span class='line'>  <span class="n">obj3</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以写成像是这样的一个表达式：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">get_best_object</span><span class="p">(</span><span class="n">obj1</span><span class="p">,</span> <span class="n">obj2</span><span class="p">,</span> <span class="n">obj3</span><span class="p">)</span>
</span><span class='line'>  <span class="k">if</span> <span class="n">obj1</span><span class="o">.</span><span class="n">price</span> <span class="o">&lt;</span> <span class="mi">20</span>
</span><span class='line'>    <span class="n">obj1</span>
</span><span class='line'>  <span class="k">elsif</span> <span class="n">obj2</span><span class="o">.</span><span class="n">quality</span> <span class="o">&gt;</span> <span class="mi">3</span>
</span><span class='line'>    <span class="n">obj2</span>
</span><span class='line'>  <span class="k">else</span>
</span><span class='line'>    <span class="n">obj3</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>确实有一点啰嗦，但逻辑比一堆行内 <code>if/unless</code> 来得清楚。经验法则告诉我们，仅在你确定会用到副作用时，使用行内条件式，而不是在变量赋值或返回的场合使用：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">country</span> <span class="o">=</span> <span class="no">Country</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span><span class='line'><span class="n">country</span><span class="o">.</span><span class="n">invade</span> <span class="k">if</span> <span class="n">country</span><span class="o">.</span><span class="n">has_oil?</span>
</span><span class='line'><span class="c1"># more code here</span>
</span></code></pre></td></tr></table></div></figure>


<h4>如何从 enumerable 创造一个 hash</h4>

<p>Vanilla Ruby 没有从 Enumerable 转到 Hash 的直接对应（本人认为是一个令人遗憾的缺陷）。这也是为什么新手持续写出下面这个糟糕的模式(而你怎么能责怪他们呢？唉！）：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">hash</span> <span class="o">=</span> <span class="p">{}</span>
</span><span class='line'><span class="n">input</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">item</span><span class="o">|</span>
</span><span class='line'>  <span class="nb">hash</span><span class="o">[</span><span class="n">item</span><span class="o">]</span> <span class="o">=</span> <span class="n">process</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'><span class="nb">hash</span>
</span></code></pre></td></tr></table></div></figure>


<p>这真的非常可怕！阿～～～！但手边有没有更好的办法呢？过去 Hash 构造子需要一个有着连续键值对的 flatten 集合 （阿，用 flatten 数组来描述映射？Lisp 曾这么做，但还是很丑陋）。幸运的是，Ruby 的最新版本也接受键值对，这样更有意义（作为 <code>hash.to_a</code> 的逆操作），现在你可以这么写：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">Hash</span><span class="o">[</span><span class="n">input</span><span class="o">.</span><span class="n">map</span> <span class="k">do</span> <span class="o">|</span><span class="n">item</span><span class="o">|</span>
</span><span class='line'>  <span class="o">[</span><span class="n">item</span><span class="p">,</span> <span class="n">process</span><span class="p">(</span><span class="n">item</span><span class="p">)</span><span class="o">]</span>
</span><span class='line'><span class="k">end</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>不赖嘛，但这打破了平常的撰写顺序。在 Ruby 我们期望从左向右写，给对象调用方法。而“好的”函数式方式是使用 <code>inject</code>：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">input</span><span class="o">.</span><span class="n">inject</span><span class="p">({})</span> <span class="k">do</span> <span class="o">|</span><span class="nb">hash</span><span class="p">,</span> <span class="n">item</span><span class="o">|</span>
</span><span class='line'>  <span class="nb">hash</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">item</span> <span class="o">=&gt;</span> <span class="n">process</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们都同意这还是很啰嗦，所以我们最好将它放在 Enumerable 模块，<a href="http://rubyworks.github.com/facets/">Facets</a> 正是这么干的。它称之为 Enumerable#mash：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">Enumerable</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">mash</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
</span><span class='line'>    <span class="nb">self</span><span class="o">.</span><span class="n">inject</span><span class="p">({})</span> <span class="k">do</span> <span class="o">|</span><span class="n">output</span><span class="p">,</span> <span class="n">item</span><span class="o">|</span>
</span><span class='line'>      <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="nb">block_given?</span> <span class="p">?</span> <span class="k">yield</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="p">:</span> <span class="n">item</span>
</span><span class='line'>      <span class="n">output</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">key</span> <span class="o">=&gt;</span> <span class="n">value</span><span class="p">)</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="o">[</span><span class="s2">&quot;functional&quot;</span><span class="p">,</span> <span class="s2">&quot;programming&quot;</span><span class="p">,</span> <span class="s2">&quot;rules&quot;</span><span class="o">].</span><span class="n">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">s</span><span class="o">|</span> <span class="o">[</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">length</span><span class="o">]</span> <span class="p">}</span><span class="o">.</span><span class="n">mash</span>
</span><span class='line'><span class="c1"># {&quot;functional&quot;=&gt;10, &quot;programming&quot;=&gt;11, &quot;rules&quot;=&gt;5}</span>
</span></code></pre></td></tr></table></div></figure>


<p>或使用 <code>mash</code> 及 选择性区块来一步完成：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="o">[</span><span class="s2">&quot;functional&quot;</span><span class="p">,</span> <span class="s2">&quot;programming&quot;</span><span class="p">,</span> <span class="s2">&quot;rules&quot;</span><span class="o">].</span><span class="n">mash</span> <span class="p">{</span> <span class="o">|</span><span class="n">s</span><span class="o">|</span> <span class="o">[</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">length</span><span class="o">]</span> <span class="p">}</span>
</span><span class='line'><span class="c1"># {&quot;functional&quot;=&gt;10, &quot;programming&quot;=&gt;11, &quot;rules&quot;=&gt;5}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>面向对象与函数式编程</h3>

<p><a href="http://www.sics.se/~joe/">Joe Armstrong</a> (Erlang 发明人) 在 “Coders At work” 谈论过面向对象编程的重用性：</p>

<p>“我认为缺少重用性是面向对象语言造成的，而不是函数式语言。面向对象语言的问题是，它们带着语言执行环境的所有隐含资讯四处乱窜。你想要的是香蕉，但看到的却是香蕉拿在大猩猩手里，而大猩猩的后面是整个丛林”</p>

<p>公平点说，我的看法是这不是面向对象编程的本质问题。你可以写出函数式的面向对象程序，但确定的是：</p>

<ul>
<li>典型的 OOP 倾向强调改变对象的状态。</li>
<li>典型的 OOP 倾向层与层之间紧密的耦合。</li>
<li>典型的 OOP 将同一性(identity)与状态的概念搞混了。</li>
<li>数据与代码的混合物，导致了概念与实际的问题产生。</li>
</ul>


<p><a href="https://twitter.com/richhickey">Rich Hickey</a>，Clojure 的发明人（一个给 JVM 用的函数式 Lisp 方言），在这场<a href="http://www.infoq.com/presentations/Value-Identity-State-Rich-Hickey">出色的演讲</a>里谈论了状态、数值以及同一性。</p>

<h3>万物皆表达式</h3>

<p>可以这么写：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">if</span> <span class="n">found_dog</span> <span class="o">==</span> <span class="n">our_dog</span>
</span><span class='line'>  <span class="nb">name</span> <span class="o">=</span> <span class="n">found_dog</span><span class="o">.</span><span class="n">name</span>
</span><span class='line'>  <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;We found our dog </span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">!&quot;</span>
</span><span class='line'><span class="k">else</span>
</span><span class='line'>  <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;No luck&quot;</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>然而，控制结构（<code>if</code>, <code>while</code>, <code>case</code> 等）也返回表达式，所以只要这样写就好：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">message</span> <span class="o">=</span> <span class="k">if</span> <span class="n">found_dog</span> <span class="o">==</span> <span class="n">my_dog</span>
</span><span class='line'>  <span class="nb">name</span> <span class="o">=</span> <span class="n">found_dog</span><span class="o">.</span><span class="n">name</span>
</span><span class='line'>  <span class="s2">&quot;We found our dog </span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">!&quot;</span>
</span><span class='line'><span class="k">else</span>
</span><span class='line'>  <span class="s2">&quot;No luck&quot;</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>这样子我们不用重复变量名 <code>message</code>，企图也更明显：当有段长的程序（用了一堆我们不在乎的变量），我们可以专注在程序在干什么（返回信息）。再强调一次，我们在缩小程序的作用域。</p>

<p>另一个函数式程序的好处是，表达式可以用来构造数据：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="ss">:name</span> <span class="o">=&gt;</span> <span class="s2">&quot;M.Cassatt&quot;</span><span class="p">,</span>
</span><span class='line'>  <span class="ss">:paintings</span> <span class="o">=&gt;</span> <span class="n">paintings</span><span class="o">.</span><span class="n">select</span> <span class="p">{</span> <span class="o">|</span><span class="nb">p</span><span class="o">|</span> <span class="nb">p</span><span class="o">.</span><span class="n">author</span> <span class="o">==</span> <span class="s2">&quot;M.Cassatt&quot;</span> <span class="p">},</span>
</span><span class='line'>  <span class="ss">:birth</span> <span class="o">=&gt;</span> <span class="n">painters</span><span class="o">.</span><span class="n">detect</span> <span class="p">{</span> <span class="o">|</span><span class="nb">p</span><span class="o">|</span> <span class="nb">p</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;M.Cassatt&quot;</span> <span class="p">}</span><span class="o">.</span><span class="n">birth</span><span class="o">.</span><span class="n">year</span><span class="p">,</span>
</span><span class='line'>  <span class="o">.</span><span class="n">.</span><span class="o">.</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>递归</h3>

<p>纯函数式语言没有隐含的状态，大量利用了递归。为了避免栈溢出，函数式使用一种称为尾递归优化(TCO)的机制。Ruby 1.9 有实作这种机制，但缺省没有打开。要是你希望你的程序，在哪都可以动的话，就不要使用它。</p>

<p>但是某些情况下，递归仍然是很有用的，即便是每次递归时都创建新的栈。注意！某些递归的用途可以用 foldings 来实现(像 Enumerable#inject)。</p>

<p>在 MRI-1.9 启用 TCO：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="ss">RubyVM</span><span class="p">:</span><span class="ss">:InstructionSequence</span><span class="o">.</span><span class="n">compile_option</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>  <span class="ss">:tailcall_optimization</span> <span class="o">=&gt;</span> <span class="kp">true</span><span class="p">,</span>
</span><span class='line'>  <span class="ss">:trace_instruction</span> <span class="o">=&gt;</span> <span class="kp">false</span><span class="p">,</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>简单例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">Math</span>
</span><span class='line'>  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">factorial_tco</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">acc</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</span><span class='line'>    <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">?</span> <span class="n">acc</span> <span class="p">:</span> <span class="n">factorial_tco</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">*</span><span class="n">acc</span><span class="p">)</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>在递归深度不太可能很深的情况下，你仍可以使用：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">Node</span>
</span><span class='line'>  <span class="n">has_many</span> <span class="ss">:children</span><span class="p">,</span> <span class="ss">:class_name</span> <span class="o">=&gt;</span> <span class="s2">&quot;Node&quot;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">all_children</span>
</span><span class='line'>    <span class="nb">self</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">flat_map</span> <span class="k">do</span> <span class="o">|</span><span class="n">child</span><span class="o">|</span>
</span><span class='line'>      <span class="o">[</span><span class="n">child</span><span class="o">]</span> <span class="o">+</span> <span class="n">child</span><span class="o">.</span><span class="n">all_children</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<h3>惰性枚举器</h3>

<p>惰性求值延迟了表达式的求值，在真正需要时才会求值。与 eager evaluation 相反，eager evaluation 当一个变量被赋值时、函数被调用时…甚至根本没用到变量等状况，都立马对表达式求值，惰性不是函数式编程的必需品，但这是个符合函数式范式的好策略（Haskell 大概是最佳的例子，弥漫着懒惰的语言）。</p>

<p>Ruby 所采用的基本上是 eager evaluation（虽然许多其它的语言，在条件还没满足前不对表达式求值，以及短路布尔运算 <code>&amp;&amp;</code>, <code>||</code> 等）。然而，与任何内置高阶函数的语言一样，延迟求值是隐性支持的，因为程序员自己决定区块何时被调用。</p>

<p>Enumerators 同样 从 Ruby 1.9 开始支持(1.8 请用 backports)，它们提供了一个简单的介面来定义惰性 enumerables。经典的例子是构造一个枚举器，返回所有的自然数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">require</span> <span class="s1">&#39;backports&#39;</span> <span class="c1"># 1.8 才需要</span>
</span><span class='line'><span class="n">natural_numbers</span> <span class="o">=</span> <span class="no">Enumerator</span><span class="o">.</span><span class="n">new</span> <span class="k">do</span> <span class="o">|</span><span class="n">yielder</span><span class="o">|</span>
</span><span class='line'>  <span class="n">number</span> <span class="o">=</span> <span class="mi">1</span>
</span><span class='line'>  <span class="kp">loop</span> <span class="k">do</span>
</span><span class='line'>    <span class="n">yielder</span><span class="o">.</span><span class="n">yield</span> <span class="n">number</span>
</span><span class='line'>    <span class="n">number</span> <span class="o">+=</span> <span class="mi">1</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以用更函数式的精神改写：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">natural_numbers</span> <span class="o">=</span> <span class="no">Enumerator</span><span class="o">.</span><span class="n">new</span> <span class="k">do</span> <span class="o">|</span><span class="n">yielder</span><span class="o">|</span>
</span><span class='line'>  <span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="mi">1</span><span class="o">.</span><span class="mi">0</span><span class="o">/</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">number</span><span class="o">|</span>
</span><span class='line'>    <span class="n">yielder</span><span class="o">.</span><span class="n">yield</span> <span class="n">number</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">natural_numbers</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</span><span class='line'><span class="c1"># [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span>
</span></code></pre></td></tr></table></div></figure>


<p>现在，试试给 <code>natural_numbers</code> 做 <code>map</code>，发生什么事？它不会停止。标准的 enumerable 方法 (<code>map</code>, <code>select</code> 等）返回一个数组，所以在输入流是无穷大时，无法正常工作。让我们扩展 Enumerator 类别，比如加入这个惰性的 Enumerator#map：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">Enumerator</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">map</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
</span><span class='line'>    <span class="no">Enumerator</span><span class="o">.</span><span class="n">new</span> <span class="k">do</span> <span class="o">|</span><span class="n">yielder</span><span class="o">|</span>
</span><span class='line'>      <span class="nb">self</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">value</span><span class="o">|</span>
</span><span class='line'>        <span class="n">yielder</span><span class="o">.</span><span class="n">yield</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
</span><span class='line'>      <span class="k">end</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>现在我们可以给所有自然数的流做 <code>map</code> 了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">natural_numbers</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="p">}</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</span><span class='line'><span class="c1"># [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]</span>
</span></code></pre></td></tr></table></div></figure>


<p>枚举器是用来构造惰性行为的区块的好东西，但你可以使用用懒惰风格，实作了所有 enumerable 方法的函式库：</p>

<p>https://github.com/yhara/enumerable-lazy</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">require</span> <span class="s1">&#39;enumerable/lazy&#39;</span>
</span><span class='line'><span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="mi">1</span><span class="o">.</span><span class="mi">0</span><span class="o">/</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">lazy</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="p">}</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">to_a</span>
</span><span class='line'><span class="c1"># [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]</span>
</span></code></pre></td></tr></table></div></figure>


<h4>惰性求值的好处</h4>

<ol>
<li><p>显而易见的好处: 无需在不必要的情况下，构造、储存完整的结构（也许，可以更有效率的使用 CPU 及内存）</p></li>
<li><p>不太显而易见的好处: 惰性求值使写程序不需要了解超出你所需的范围。让我们看一个例子：你写了某种解题工具，可以提供无数种解法，但在某个时候，你只想要前十种解法。你可能会这么写：</p></li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">solver</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="ss">:max</span> <span class="o">=&gt;</span> <span class="mi">10</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>当你与惰性结构一起工作时，不需要说什么时候该结束。调用者自己会决定他需要多少值。代码变得更简单，责任归属到对的地方，也就是调用者：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">solver</span><span class="p">(</span><span class="n">input</span><span class="p">)</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h3>一个实际的例子</h3>

<p>练习：“前十个平方可被五整除的自然数的和是多少？”</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">Integer</span><span class="o">::</span><span class="n">natural</span><span class="o">.</span><span class="n">select</span> <span class="p">{</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">%</span> <span class="mi">5</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">}</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">inject</span><span class="p">(</span><span class="ss">:+</span><span class="p">)</span> <span class="c1">#=&gt; 275</span>
</span></code></pre></td></tr></table></div></figure>


<p>让我们跟等价的命令式版本来比较：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">n</span><span class="p">,</span> <span class="n">num_elements</span><span class="p">,</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
</span><span class='line'><span class="k">while</span> <span class="n">num_elements</span> <span class="o">&lt;</span> <span class="mi">10</span>
</span><span class='line'>  <span class="k">if</span> <span class="n">n</span><span class="o">**</span><span class="mi">2</span> <span class="o">%</span> <span class="mi">5</span> <span class="o">==</span> <span class="mi">0</span>
</span><span class='line'>    <span class="n">sum</span> <span class="o">+=</span> <span class="n">n</span>
</span><span class='line'>    <span class="n">num_elements</span> <span class="o">+=</span> <span class="mi">1</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>  <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'><span class="n">sum</span> <span class="c1">#=&gt; 275</span>
</span></code></pre></td></tr></table></div></figure>


<p>我希望这个例子展示了这个文档里讨论的函数式编程的优点：</p>

<ol>
<li><p>更简洁: 你会撰写更少的代码。函数式程序处理的是表达式，而表达式可以连锁起来；命令式程序处理的是变量的改动（叙述式），而这不能连锁。</p></li>
<li><p>更抽象: 你可以争论我们使用 <code>select</code>, <code>inject</code>…等等，来隐藏了一大堆代码，我很高兴你这么说，因为我们正是这么干的。将通用的、可重用的代码隐藏起来，这是所有编程的重点 –– 但函数式编程特别是关于如何撰写抽象。感到开心不是因为写了更少的代码，而是因为藉由认出可重用的模式，简化了代码的复杂性。</p></li>
<li><p>更有声明式的味道: 看看命令式的版本，第一眼看起来是一坨无用的代码 –– 没有注解的话 –– 它会做什么你完全没有概念。你可能会说：“好吧，从这里开始读，草草记下 <code>n</code> 与 <code>sum</code> 的值，进入某个循环，看看 <code>n</code> 与 <code>sum</code> 的值如何变化，看看最后一次迭代的情形” 等等。函数式版本另一方面是自我解释的，函数式版本描述、声明它在干的事，而不是如何干这件事。</p></li>
</ol>


<p>“函数式编程就像是将你的问题叙述给数学家一样。命令式编程像是给白痴下指令” (arcus 在 Freenode #scheme 频道所说）</p>

<h3>结论</h3>

<p>更好的理解函数式编程的原理，帮助我们写出更清晰、重用性更高并更简洁的代码。Ruby 基本上是一个命令式语言，但它也有很大的函数式能力，明白什么时候用，及如何用（以及何时不该用）这些能力。将这句话当成你的座右铭吧 “状态是万恶的根源，尽可能避免它。”</p>

<h3>展示</h3>

<p>Workshop at <a href="http://conferenciarails.org/">Conferencia Rails 2011</a>: <a href="http://public.arnau-sanchez.com/ruby-functional/">Functional Programming with Ruby</a> <a href="http://www.slideshare.net/tokland/functional-programming-with-ruby-9975242">(slideshare)</a></p>

<h3>延伸阅读</h3>

<p>http://en.wikipedia.org/wiki/Functional_programming</p>

<p>https://github.com/JuanitoFatas/Ruby-Functional-Programming/blob/master/RADME-zhCN.md</p>

<p>http://www.defmacro.org/ramblings/fp.html <strong><a href="http://t.cn/zYaCDw7">译文</a></strong></p>

<p>http://www.cse.chalmers.se/~rjmh/Papers/whyfp.html</p>

<p>http://www.khelll.com/blog/ruby/ruby-and-functional-programming/</p>

<p>http://www.bestechvideos.com/2008/11/30/rubyconf-2008-better-ruby-through-functional-programming</p>

<p>http://channel9.msdn.com/Blogs/pdc2008/TL11</p>

<p>http://www.infoq.com/presentations/Value-Identity-State-Rich-Hickey</p>

<h2>授权</h2>

<p>This document is licensed under the CC-By 3.0 License, which encourages you to share these documents. See http://creativecommons.org/licenses/by/3.0/ for more details.</p>

<p><img alt="CC-By 3.0 License http://creativecommons.org/licenses/by/3.0/" style="border-width:0" src="http://i.creativecommons.org/l/by/3.0/88x31.png" /></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/05/06/set-local-octopress-env/">为已托管在github的octopress配置本地环境</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-05-06T13:00:00+08:00" pubdate data-updated="true">May 6<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>1.本地安装Ruby
2.从你的github获取已托管的octopress内容</p>

<pre><code>git clone -b source git@github.com:username/username.github.com.git octopress # get the source code from your "source" branch of your octopress on github
cd octopress
git clone git@github.com:username/username.github.com.git _deploy # get your static pages content from your "master"branch of your cotopress on github
</code></pre>

<p>3.安装依赖gems</p>

<pre><code>gem install bundler # Install dependencies
bundle install
rake install # Install the default Octopress theme
</code></pre>

<p>4.编写文章并部署</p>

<pre><code>cd octopress
rake new_post["Title"]
rake generate 
rake preview 
rake deploy 
</code></pre>

<p>5.提交文本修改到github</p>

<pre><code>cd octopress
git add .
git commit -m 'message'
git push origin source
</code></pre>

<p><strong>注：从github得到最新的source内容</strong></p>

<pre><code>cd octopress
cd _deploy
git pull origin master
cd ..
git pull origin source
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/05/06/draft-mccann-dmm-flatarch-00/">Draft-mccann-dmm-flatarch-00</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-05-06T10:59:00+08:00" pubdate data-updated="true">May 6<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>Authentication and Mobility Management in a Flat Architecture</h1>

<h3><a href="http://tools.ietf.org/html/draft-mccann-dmm-flatarch-00">draft-mccann-dmm-flatarch-00</a></h3>

<p>从运营商角度看待移动性管理，包含部署、身份认证等，略之</p>

<hr />
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/05/06/draft-ma-dmm-romip-00/">Draft-ma-dmm-romip-00</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-05-06T10:55:00+08:00" pubdate data-updated="true">May 6<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>A Route Optimization solution support for Distributed Mobility Management</h1>

<h3><a href="http://tools.ietf.org/id/draft-ma-dmm-romip-00.txt">draft-ma-dmm-romip-00</a></h3>

<p>The first elements that provide IP connectivity to a set of MNs are also the mobility managers for those MNs.</p>

<ul>
<li>移动节点不参与任何与移动相关的信令交互。移动锚和接入路由器以及AAA代表主机负责管理IP移动性。</li>
<li>The Home Address (HoA 切换前MAAR分配的地址) and Care-of address (CoA 切换后MAAR分配的地址).</li>
<li>移动节点可以直接向通信节点发送数据包而不需要通过家乡移动锚。</li>
</ul>


<hr />

<h2>1.  Introduction</h2>

<ol>
<li>MIPv6 和 PMIPv6的缺点</li>
<li>在论文“<a href="http://eprints.networks.imdea.org/13/1/giust_mmfn2011.pdf">一个基于网络的分布式移动管理的局部性移动解决方案</a>”中，作者表述了两种方法：一个是完全分布式的方法，另一个是部分分布式的方法。第一个方法的主要问题是，如何在第一次连接到网络的时候和随后的切换之间区分移动锚和接入路由器。</li>
<li>这篇文档描述了移动锚和接入路由器以及AAA协议代表主机对IP移动性的支持。这个解决方案能解决两方面的问题，它不仅使得移动实体能在第一次接入网络时和随后的切换之间进行区分，而且能减少家乡移动锚的重担。移动节点能直接向通信节点转发数据包。数据包的发送不需要通过家乡移动锚。 这篇文档时严格遵照这两方面进行展开。</li>
<li>所遵循的两个原则:移动节点的移动对通信节点来说是透明的；移动节点不参与任何与移动相关的信令交互。</li>
</ol>


<h2>2.  Terminology</h2>

<ul>
<li>MAAR (Mobility anchor and Access Router)</li>
<li>AAA (Authentication, Authorization and Accounting )</li>
<li>DBU/DBA (Distributed BU/BA)</li>
<li>sDBU/sDBA.  The MAAR attached by the MN currently to sends a sDBU message to the MAAR attached by MN before the MN&#8217;s movement.  After that, the MAAR attached by MN currently receives a sDBA message including the address of CN&#8217;s MAAR which the CN is currently attached to.  After that, the MAAR attached by the MN currently updates its internal binding list.</li>
<li>dDBU/dDBA.  The MAAR attached by the MN currently sends a dDBU message to the MAAR attached by CN for refreshing the internal binding list of the CN&#8217;s MAAR which the CN is currently attached to. After receiving the dDBU message, the CN&#8217;s MAAR replies a dDBA message to the MN&#8217;s MAAR.</li>
</ul>


<h2>3.  Operation</h2>

<pre><code>+----------+  +----------+ +-------+  +-------+   +-------+     +-----+
|The user A|  |The user B| |A_MAAR2|  |B_MAAR2|   |A_MAAR3|     | AAA |
+----------+  +----------+ +-------+  +-------+   +-------+     +-----+
     |             |           |          |           |             |
     |--------------1.RS(A_HoA1,B_HoA1)--------------&gt;|             |
     |             |           |          |           |-2.request--&gt;|
     |             |           |          |           |&lt;-3.response-|
     |&lt;-------------------4.RA(A_HoA3) ---------------|             |
     |             |           |          |           |             |
     |             |           |&lt;-------5.sDBU -------|             |
     |             |           |------6. sDBA -------&gt;|             |
     |             |           |          |&lt;-7.dDBU --|             |
     |             |           |          |--8.dDBA -&gt;|             |
     |             |           |          |           |             |


                 Figure 1:Signaling of MN handover



  ________                          ________
 |The user|                        |The user|
 |   B    |----------move---------&gt;|   B    |
 |________|                        |________|
                                      #  *
                                      #  *
                                      #  *
  +-------+                       +-------+
  |       |                       |       |
  |B_MAAR1|                       |B_MAAR2|
  |       |                     / |       |
  +-------+                    /  +-------+
                              /  #  /| * |
                             /  #  / | * |
                            /  #  /  | * |
                           /  #  /   | * |
                          /  #  /    | * |
                         /  #  /     | * |
+-------+        +-------+ #  /    +-------+
|       |        |       |   /     |       |
|A_MAAR1|        |A_MAAR2|  /      |A_MAAR3|
|       |        |       |         |       |
+-------+        +-------+         +-------+
                    #                   *
                    #                   *
                    #                   *
 ________         ________             ________
|The user|       |The user|           |The user|
|   A    |-move-&gt;|   A    |---move---&gt;|   A    |
|________|       |________|           |________|


             Figure 2:The transmission of data packets
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/05/06/draft-ma-dmm-armip-00/">Draft-ma-dmm-armip-00</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-05-06T10:50:00+08:00" pubdate data-updated="true">May 6<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>An AR-level solution support for Distributed Mobility Management</h1>

<h3><a href="https://tools.ietf.org/html/draft-ma-dmm-armip-00">draft-ma-dmm-armip-00</a></h3>

<hr />

<h2>1.  Introduction</h2>

<p>这篇文档以主机的方式描述了MAAR和AAA对IP移动性管理的支持。这能够解决移动实体对第一次连接到网络和随后切换之间的区分这一问题。本文件严格遵守两个原则。第一个是，MN（移动节点）的移动对CN（核心网络）是透明的。另一个是MN（移动节点）不参与任何和移动性相关的信令传输。</p>

<h2>2.  Terminology</h2>

<ul>
<li>MAAR(Mobility anchor and Access Router)</li>
<li>AMAAR (Accessing MAAR).指当前MN连接到的MAAR.每个ALMN必须为当前注册过的移动节点建立并维护两个绑定的列表。一个是内部绑定列表，另一个是外部绑定列表。每一个AMAAR都为新用户配置IPv6地址。因此AMAAR代表每一个移动节点执行移动性管理。每个AMAAR负责检测移动节点的运动和接入链路，并且用于绑定注册的初始化。</li>
<li>FMAAR (Forwarding MAAR).指被MN以前访问过的MAAR，仍有active flow。MN可以具有一个或多个FMAAR。</li>
<li>AAA (Authentication, Authorization and Accounting). AAA服务器记录用户的静态和动态信息，而动态信息包括该MN当前注册的MAAR的地址信息。</li>
<li><p>DBU/DBA (Distributed BU/BA).一个MAAR发送DBU/DBA消息给另一个MAAR来建立相应的绑定列表。在本文中，有两种DBU/DBA信息。一个是pDBU/pDBA消息，另一个是的fDBU/ fDBA消息。</p></li>
<li><p>pDBU/pDBA.pDBU消息是通过移动节点的AMAAR发送给PMAAR,目的是在移动节点的AMAAR和PMAAR之间建立绑定。这个消息包括了AMAAR的地址。收到pDBU消息后，PMAAR给AMAAR发送一个pDBA消息进行答复，此消息包括FMAAR的地址和由FMAAR分配的MN的地址。fDBU/fDBA.fDBA消息由移动节点的AMAAR发送给FMAAR（不包括PMAAR），目的是在移动节点的AMAAR和FMAAR(不包括PMAAR)之间建立绑定。这个消息包括AMAAR的地址。收到fDBU消息后，FMAAR会给AMAAR发送一个fDBA消息进行答复。</p></li>
</ul>


<h2>3.  MAAR Operation</h2>

<h4>关键操作</h4>

<ul>
<li>AMAAR MUST send diameter request message to the AAA after detecting the MN&#8217;s movement to the access link.AAA能够区分MN是第一次连接，还是切换后的连接。</li>
<li>MAAR 维护两个绑定列表，内部绑定列表和外部的绑定列表。内部列表里绑定FMAAR分配的MN地址和MN的FMAAR的地址；内部绑定列表里绑定AMAAR分配的MN的地址和FMAAR分配的此MN的地址。</li>
<li>每个FMAAR必须为每个之前注册过的MN维护一个绑定列表。这张列表存储了由FMAAR分配的MN的地址的绑定和此MN的AMAAR的地址。</li>
<li>AMAAR和PMAAR建立双向隧道转发属于MN的所有数据流量。（地址绑定——AMAAR从AAA那获取PMAAR地址，AMAAR向PMAAR发送pDBU）</li>
</ul>


<h2>4.  Description of the solution</h2>

<p>分布式移动管理方法的目的是克服传统的集中式移动管理的限制，通过使移动锚点更接近MN.遵循这一理念，我们建议，中央锚移动到网络的边缘，被部署在所述移动节点的接入路由器。也就是说，提供MN IP连通性的第一个元素也就是这些MN的移动管理者。</p>

<pre><code>    +-----+     +------+   +------+       +------+          +----+
    |  MN |     | MAAR1|   | MAAR2|       | MAAR3|          | AAA|
    +-----+     +------+   +------+       +------+          +----+
       |           |           |             |                 |
       |-----------1.RS(HoA1,HoA2)----------&gt;|                 |
       |           |           |             |----2.request---&gt;|
       |           |           |             |&lt;---3.response---|
       |&lt;----------4.RA(HoA3)--------------- |                 |
       |           |           |             |                 |
       |           |           |&lt;--5.pDBU ---|                 |
       |           |           |--6. pDBA --&gt;|                 |
       |           |&lt;--------7.fDBU ---------|                 |
       |           |---------8.fDBA --------&gt;|                 |
       |           |                         |                 |



                 Figure 1:Signaling of MN handover
</code></pre>

<ol>
<li>MN从MAAR1，MAAR2 切换到MAAR3，MN发送一个包含HoA1和HoA2的消息给MAAR3。</li>
<li>MAAR3发送diameter请求信息给AAA</li>
<li>AAA有MAAR2的地址信息。AAA发送包含MAAR2的diameter答复信息，然后AAA更新包括MAAR3地址信息在内的MN的动态信息。</li>
<li>MAAR3分配给MN另一个IPv6地址（HoA3）。同时，MAAR3建立并维护存储HoA1和HoA3，HoA2和HoA3绑定的外部绑定列表。</li>
<li>与此同时，MAAR3发送包含MAAR3地址的pDBU信息给MAAR2.</li>
<li>现在MAAR2有两个绑定列表。一个是内部绑定列表，另一个是外部绑定列表。第一个存储MAAR1的地址和HoA1。第二个存储HoA1和HoA1的绑定。在收到pDBU信息之后，MAAR2发送包括内部绑定列表、HoA2和MAAR2的地址在内的pDBA信息。之后，MAAR2用一个存储了HoA2和MAAR3地址的绑定列表替换这两个绑定列表。</li>
<li>在收到pDBA信息后，MAAR3建立并维护这个存储了HoA1和MAAR1的地址绑定、HoA2和MAAR2的地址绑定的内部绑定列表。MAAR3发送包含MAAR3地址的fDBU信息给MAAR1。</li>
<li>在收到fDBU信息后，MAAR1回复一个fDBA信息，并且更新之前存储HoA1和MAAR2的地址的绑定列表。这个列表现在存储了HoA1和MAAR3的地址。</li>
</ol>


<h2>5.  Forwarding Considerations</h2>

<p>在收到有MN发送的数据包后，AMAAR将会检查数据包的源地址。如果这个地址是由AMAAR分配的，AMAAR就会根据包的目的地址将包转发给CN。如果地址不是由AMAAR分配的，AMAAR就会根据源地址搜索内部绑定列表，然后找到相应的FMAAR的地址。然后，AMAAR封装这些包到相应的FMAAR。</p>

<pre><code>    _______         _______          _______
   |       |       |       |        |       |
   |  CN1  |       |  CN2  |        |  CN3  |
   |_______|       |_______|        |_______|
       '               *  Flow#2         .
Flow#1 '               *                 | Flow#3
       '  ..... '''''''*''''''''''''..... .
     ..'''             *                 '''..
   .'  '            IP * network         .   '.
   :   '               *                 |    :
    '..'           +-------+             . ..'
       '''.......  |       |    ........'''
       '           | MAAR2 |\            .
       '           |       | \           |
       '           |       |* \          .
       '           +-------+\* \         |
 +-------+                   \* \ + ------+
 |       |                    \*  |       |
 | MAAR1 |------------------------| MAAR3 |
 |       |''''''''''''''''''''''''|       |
 |       |------------------------|       |
 +-------+                        +-------+
                                     ' * |
                             Flow#1  ' * . Flow#3
                                     ' * |
   +-----+                   Flow#2 +-----+
   | MN  | ----------move---------&gt; | MN  |
   +-----+                          +-----+


              Figure 2:The transmission of data packets
</code></pre>

<h2>6.  Message Formats</h2>

<p>略</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/05/06/draft-luo-dmm-with-mip-and-pmip-00/">Draft-luo-dmm-with-mip-and-pmip-00</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-05-06T10:50:00+08:00" pubdate data-updated="true">May 6<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>Distributed Mobility Management Approach with Mobile IP and Proxy Mobile IP</h1>

<h3><a href="http://tools.ietf.org/html/draft-luo-dmm-with-mip-and-pmip-00">draft-luo-dmm-with-mip-and-pmip-00</a></h3>

<pre><code>本文提出了分布式移动管理体系结构的概念以及该结构的一些主要处理方法。
这些处理方法可以兼容现有的移动IP和代理移动IP协议。
</code></pre>

<hr />

<h2>Introduction</h2>

<p>集中式移动锚定有一些诸如单点故障、非最优路径路由等缺点。这些缺点在<a href="http://tools.ietf.org/html/draft-liu-mext-distributed-mobile-ip-00">I-D.liu-mext-distributed-mobile-ip</a>中讨论过了。</p>

<p>本文提出了分布式移动管理体系结构的概念以及该结构的一些主要处理方法。这些处理方法可以兼容现有的移动IP和代理移动IP协议。</p>

<p>本文只是一个初稿，并不为了解决<a href="http://tools.ietf.org/html/draft-liu-mext-distributed-mobile-ip-00">I-D.liu-mext-distributed-mobile-ip</a>中所提出的所有问题。</p>

<h2>Terminology</h2>

<p>移动路由(MR)，这是一个逻辑功能，用于拦截从移动节点和HoA发送/接收的数据包并转发数据包，根据位置信息执行分布式路由选择。</p>

<p>主地址分配(HAA)，这是一个逻辑功能，用于向一个移动节点分配主网络前缀或主地址。</p>

<p>位置管理(LM)，这是一个逻辑功能，用于管理并跟踪移动节点位置信息，其中包括MN的HoA与MN路由地址(或另一网络元素，它知道如何对MN的数据包进行转发)的映射。</p>

<h2>Solution Overview</h2>

<p>本方案将集中式锚点分解为下列逻辑功能，来允许使用更灵活的设计来实现DMM：</p>

<ul>
<li><p>主地址分配功能</p></li>
<li><p>移动路由功能</p></li>
<li><p>位置管理功能</p>

<pre><code>          One Administrative Domain

  (     LM1/HAA1    )(  LM2/HAA2 )(   LM3   HAA3  )
  (                 )(           )(               )
  (                 )(           )(               )
  (  MR11     MR12  )(     MR2   )( MR31    MR32  )
      +                               +
      |     Local        Local        |     Local
      |    Network1     Network2      |    Network3
      +                               +
     MN1                             MN2

     Figure 1.  An example of DMM deployment
</code></pre></li>
</ul>


<p>本文中假设所有本地网络均属于同一个管理域。</p>

<p>MN最初连接的本地网络被称为它的Home Local Network。HAA功能是负责移动节点的IP地址\分配（例如HoA\HNP）。在移动过程中，移动节点可以离开它的Home Local Network进入另一个本地网络——Visited Local Network。</p>

<pre><code>+-------------------------------------+  +--------------------------+
|  +---------+         +---------+    |  |        +---------+       |
|  |   HAA   |         |   LM    +&lt;---+--+-------&gt;+   LM    |       |
|  +---+-----+         +----+----+    |  |        +----+----+       |
|      ;                   /|\        |  |            /|\           |
|     /|\                   |         |  |             |            |
|      |                   \|/        |  |            \|/           |
|      |               +----+----+    |  |        +----+----+       |
|      +-------------&gt; |   MR    +&lt;---+--+-------&gt;+   MR    |       |
|                      +--+---+--+    |  |        +--+---+--+       |
|                        /|\ /|\      |  |          /|\ /|\         |
|                         |   |       |  |           |   |          |
|                         |___|       |  |           |___|          |
|                                     |  |                          |
| Home Local Network                  |  | Visited Local Network    |
+-------------------------------------+  +--------------------------+

 Figure 2.  Architecture
</code></pre>

<p>HAA、LM和MR之间需要接口，它们被描述如下：</p>

<pre><code>   a.  HAA和MR之间的接口支持当在MN依附MR时，IP前缀或地址的分配。

   b.  LM和MR之间的接口支持MN路由位置管理，以及为MN设置最优路由。

   c.  MR和MR之间的接口支持在控制平面MN从原MR（pMR）切换到新的MR（nMR），并支持在数据平面以分布式的方式分发MN与CN间的流量
</code></pre>

<p>一个管理域可能存在大量的移动节点，LM可能需要保存大量的信息，LM可以以分布式数据库的形式来部署。</p>

<h2>Overview of the Distributed Mobility Management Approaches</h2>

<h4>Initial Attachment</h4>

<h4>Dynamic Mobility Management</h4>

<ol>
<li>pMR和nMR的HoA\HNP对于移动节点是可用</li>
<li>nMR下新发起的会话，优选使用新的HoA\HNP作为源IP</li>
<li>切换前发起的旧会话仍然可以使用旧的HoA\HNP作为源IP。</li>
</ol>


<p>上述策略基于以下前提：</p>

<ol>
<li><strong>移动节点应该可以管理多个HoAs\HNP</strong>。</li>
<li><strong>MN可以在MN上的应用请求IP地址绑定时决定返回哪一个HoA</strong>。</li>
</ol>


<h4>Distributed Routing</h4>

<pre><code>+-----+      +-------+     +-------+    +--------+     +-----+
| MN2 |      |  MR31 |     |  LM   |    |  MR11  |     | MN1 |
+-----+      +-------+     +-------+    +--------+     +-----+
   |             |            |             |             |
   |1.IP Traffic |            |             |             |
   |===========&gt; | 2. Query   |             |             |
   |             |----------&gt; |             |             |
   |             | 3. Rsp     |             |             |
   |             |&lt;------ ----|             |             |
   |   +------------------+   |             |             |
   |   | 4.Record Location|   |             |             |
   |   |   of MN1 Locally |   |             |             |
   |   +------------------+   |             |             |
   |             |  5. Distributed Routing  |             |
   |             |========================&gt; |             |
   |             |            |             |6.IP Traffic |
   |             |            |             |===========&gt; |
   |             |            |             |             |

    Figure 3.  Optimized routing based on location query



+-----+      +-------+     +-------+    +--------+   +--------+   +-----+
| MN2 |      |  MR31 |     |  LM1  |    |  MR12  |   |  MR11  |   | MN1 |
+-----+      +-------+     +-------+    +--------+   +--------+   +-----+
   |             |            |             |            |           |
   |1.IP Traffic |            |             |            |           |
   |============&gt;|            |             |            |           |
   |    +-------------------+ |             |            |           |
   |    |2.Don't have MN1's | |             |            |           |
   |    |  Routing Location | |             |            |           |
   |    +-------------------+ |             |            |           |
   |             | 3. Regular IPv6 Routing  |            |           |
   |             |========================&gt; |            |           |
   |             |            |   4. Query  |            |           |
   |             |            |&lt;------------|            |           |
   |             |            |   5. Rsp    | 6. Distributed         |
   |             |            |------------&gt;|    Routing             |
   |             |     8. Redirect          |===========&gt;|           |
   |             |&lt;-------------------------|            7.IP Traffic|
   |             |            |             |            |==========&gt;|
   |             |         9. Distributed Routing        |           |
   |             |======================================&gt;|           |
   |             |            |             |           10.IP Traffic|
   |             |            |             |            |==========&gt;|
   |             |            |             |            |           |
   |             |            |             |            |           |

       Figure 4.  Another approach for optimized routing


+---+     +--------+   +--------+   +-------+  +--------+     +---+
|MN1|     |  MR11  |   |   MR2  |   |  LM1  |  |  MR31  |     |MN2|
+---+     +--------+   +--------+   +-------+  +--------+     +---+
  |            |            |           |           |           |
  |            |           1. Ongoing traffic       |           |
  |&lt;==========&gt;|&lt;==================================&gt;|&lt;========&gt; |
  |            |  2. Context|           |           |           |
  |            |  Transfer  |           |           |           |
  |            |&lt;----------&gt;|           |           | 3. IP     |
  |            |            |           |           | Traffic   |
  |            |            4. Distributed Routing  |&lt;========= |
  |            |&lt;===================================|           |
  |            |5. Transfer |           |           |           |
  |            |==========&gt; |           |           |           |
  |    6. IP Traffic        |           |           |           |
  |&lt;======================= |           |           |           |
  |            |            | 7. Redirect           |           |
  |            |----------------------------------&gt; |           |
  |            |            |           | +----------------+    |
  |            |            |           | | 8. Update      |    |
  |            |            |           | | Location of MN1|    |
  |            |            |           | +----------------+    |
  |            |            |           |           |  9. IP    |
  |            |            |           |           |  Traffic  |
  |            |            |10. Distributed Routing|&lt;==========|
  |    11. IP Traffic       |&lt;======================|           |
  |&lt;========================|                       |           |
  |            |            |                       |           |

        Figure 5.  Handover with Active Session
</code></pre>

<h2>Considerations of the Optimized Routing</h2>

<p>CN被假定为移动节点。这意味着CN必须连接到一个确定的MR，而且这个MR必须跟踪CN的位置并解析从CN到MN的所有数据包。但是，当CN为固定节点时，可能就没有这样为CN服务的MR了。</p>

<p>现实环境中，大多数的固定节点（CN）都以一种集中的方式被部署，例如CDN/IDC/Web服务器等。这些固定节点一般是由同一对接入路由器汇聚，即使那些固定的节点的接入运营商的IP承载网拓扑可能是非常复杂的。 图6是一个示例。</p>

<pre><code>   __________
  /    CN     \            ,--------.
((CDN\IDC\Web )---Access Router     `.
(   Server)   )    ,--'               `'
 \___________/     \                 _ -'
                    '--  MR  -----''
                          |
                          |
                         MN1

 Figure 6.  CNs are fixed nodes
</code></pre>

<p>对于在图6中描述的场景，直接的解决方案是利用所谓的汇聚接入路由器或网关路由器（即在上图标出的接入路由器）实现MR功能。</p>

<p>另一种替代方法是使用<a href="http://tools.ietf.org/html/draft-chan-dmm-framework-gap-analysis-06">I-D.chan-dmm-framework-gap-analysis</a>和<a href="http://tools.ietf.org/html/draft-wakikawa-mext-global-haha-spec-02">I-D.wakikawa-mext-global-haha-spec</a>中所描述的anycast机制。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/05/06/draft-luo-dmm-with-ipv6-prefix-properties-00/">Draft-luo-dmm-with-ipv6-prefix-properties-00</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-05-06T10:45:00+08:00" pubdate data-updated="true">May 6<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>Distributed Mobility Management Approaches with IPv6 Prefix Properties</h1>

<h3><a href="http://tools.ietf.org/html/draft-luo-dmm-with-ipv6-prefix-properties-00">draft-luo-dmm-with-ipv6-prefix-properties-00</a></h3>

<p>为了支持一个更分布的模型，本文扩展了现有的基于PMIP的移动性管理协议，并通过引入两个新的逻辑功能来实现分布式锚定和定位管理。鉴于MN可能并不总是需要移动性支持，即需要应用全局性前缀和其他的网络资源，本草案支持该选项以此来补充IPv6前缀源地址选择提示（即IPv6邻居发现协议和它的前缀信息选项）的扩展属性，实现了UE可以根据其服务/应用的移动性支持需求来选择IPv6的前缀。当MN支持扩展的前缀属性功能时，该草案允许ＭＮ可以根据 I-D.korhonen-dmm-prefix-properties 里描述的机制来选择合适的前缀。一旦确定了IPv6前缀，其余的ＤＭＭ机制则与I-D.luo-dmm-pmip-based-dmm-approach 类似。</p>

<hr />

<h2>Solution Overview</h2>

<p>两个新的逻辑功能:</p>

<ul>
<li>位置管理功能（LMF）， 用来维护IP地址与MN位置之间的匹配</li>
<li>分布式定位功能（DAF）用来对MN的第一跳路由器提供本地定位支持，并在 I-D.luo-dmm-pmip-based-dmm-approach 第七部分中进行了描述，被称为增强型的LMA（eLMA）并且与在 RFC5213 中描述的LMA具有相似的性质。</li>
</ul>


<p>DAF由分布式路由子功能（DRF）和分布式移动子功能（DMF）组成：</p>

<ul>
<li>DRF在MN的第一跳路由器上作为分布式隧道端点进行操作，以此来支持在两个DMM端点（例如MN与其相应的节点，如CN）之间的优化的路由。</li>
<li>DMF用来支持移动节点的移动性切换操作，减少在优化的路由建立的过程中数据包的丢失。</li>
</ul>


<p>在初始的MN附着中，本方案通过重新使用一个选项，即利用korhonen方案<a href="http://tools.ietf.org/html/draft-korhonen-dmm-prefix-properties-02">I-D.korhonen-dmm-prefix-properties</a>向MN传达IPv6前缀的源地址选择提示（例如在本草案中定义的前缀信息选项‘M’标志）。</p>

<pre><code>     Internet
        |           +-----+
        |           | LMF |
  Border Router     +-----+
        |
        +-----------------+---------
                          |
                      +---+---+
                      | eLMA1 |
                      | (DAF) |
                      +--+----+
           Global Prefix |  |Local Prefix
               (PreB)    |  |  (PreA)
                         V  V
                        +----+
                        | MN |
                        +----+
        IP1: From PreA (Local, without mobility)
        IP2: From PreB (Global, with mobility)

              Figure 1.  Initial Attach
</code></pre>

<p>当eLMA检测到一个初始的MN附件时，它会像该MN发出一个RA消息。该RA包括IPv6前缀，每个前缀都被它的属性进行标记，包括它的移动管理属性。根据移动管理属性，IPv6前缀被MN区分为两类，即全局前缀和本地前缀。它们被定义如下:</p>

<ul>
<li>全局前缀：如果一个来自全局前缀的IPv6地址被用作一个会话的源地址，那么将通过使用本草案中规定的移动性管理机制来向该会话提供完全的移动性支持。这意味着即使连接点改变了，地址始终保持有效。</li>
<li>本地前缀：如果一个来自本地前缀的IPv6地址被用作一个会话的源地址，不向该会话提供或者只提供有一定限制的移动性支持。那么当连接点改变的时候，地址可能不是有效的。</li>
</ul>


<p>根据已获取的移动性管理性质，MN根据IPv6前缀的两种分类来支持它的服务应用。如果MN的应用需要移动性支持，MN将通过让应用调用一个适当的API套接字扩展来从全局前缀中获取一个IPv6地址。反之，如果MN的应用不需要或者只要求有限的移动性支持，MN将通过调用另一个适当的API套接字扩展来从本地前缀中获取一个IPv6地址。</p>

<p>网络不会向本地IPv6前缀提供移动性，这意味着当MN改变它的连接点时（如eLMA)，那么前一个eLMA分配的本地前缀将被弃用\无效。当连接到下一个eLMA时，新的eLMA会分配一个新的本地前缀。</p>

<p>eLMA只为那些全局前缀向LMF更新位置信息。</p>

<h2>Detailed Scenarios and Approaches</h2>

<h4>Initial Attach</h4>

<p>当eLMA1检测到一个移动节点的最初链接，它向该移动节点发送一条RA消息。该RA包含两种前缀：本地前缀（PreA）和全局前缀（PreB）。eLMA应该根据[I-D.korhonen-dmm-prefix-properties]给PreA(如本地前缀)(http://tools.ietf.org/html/draft-korhonen-dmm-prefix-properties-02)分配一个高优先级，同时给PreB(如全局前缀)分配一个低优先级。</p>

<p>移动节点的应用可以选择一个合适的IPv6地址作为它的源地址，如<a href="http://tools.ietf.org/html/draft-korhonen-dmm-prefix-properties-02">I-D.korhonen-dmm-prefix-properties</a>中第4节描述的。</p>

<h4>Data forwarding</h4>

<pre><code>                                IP1 as destination:
                                common routing
                          |             +-------+       +----+
                          |             | eLMA3 |_______| CN |
       +-----+            +-------------+ (DAF) |       +----+
       | LMF |            |             +-------+
       +-----+            |     IP2 as destination:
                          |     Routing based on location
       --------------+----+     (e.g. IP in IP tunnel)
                     |
                 +---+---+
                 | eLMA1 |
                 | (DAF) |
                 +--+----+
      Global Prefix |  |Local Prefix
          (PreB)    |  |  (PreA)
                    V  V
                   +----+
                   | MN |
                   +----+
   IP1: From PreA (Local, without mobility)
   IP2: From PreB (Global, with mobility)

        Figure 2.1 Data forwarding mechanism
</code></pre>

<p>当通信节点（CN）向MN发送消息时，首先到达CN的eLMA3。eLMA3将根据目的IPv6地址的类别进行操作：</p>

<ol>
<li>如果目的IPv6包含本地IPv6前缀（图2.1中的IP1），eLMA3将使用通用的路由机制来发送IP包。</li>
<li>如果目的IPv6地址包含全局IPv6前缀（图2.1中的IP2），那么eLMA3将使用<a href="http://tools.ietf.org/id/draft-luo-dmm-pmip-based-dmm-approach-01.txt">I-D.luo-dmm-pmip-based-dmm-approach</a>7.2节中描述的路由机制来发送IP包。</li>
</ol>


<h4>Handoff Scenario</h4>

<pre><code>                                          IP1 as destination:
                                          can not be reachable
                                          after handoff
    Internet                              IP3 as destination:
        |                                 common routing
        |                                     +-------+       +----+
        |                              |      | eLMA3 |_______| CN |
        |          +-----+             +------+ (DAF) |       +----+
  Border Router    | LMF |             |      +-------+
        |          +-----+             |  IP2 as destination:
        |                              |  Routing based on location
        +-----+---------------------+--+
              |                     |
          +---+---+             +---+---+
          | eLMA2 |             | eLMA1 |
          | (DAF) |             | (DAF) |
          +-------+             +--+----+
Local Prefix |  |   Global Prefix   |  |Local Prefix
  (PreC)     |  |       (PreB)      |  |  (PreA)
             V  V                   V  V
            +----+                 +----+
            | MN |   &lt;------------ | MN |
            +----+                 +----+
 IP3: From PreC                IP1: From PreA
 (Local, without mobility)     (Local, without mobility)
 IP2:Keep unchanged            IP2: From PreB
 (Global, with mobility)       (Global, with mobility)

   Figure 3.1 Handover Scenario
</code></pre>

<p>从CN发送到IP1（从PreA中配置的）的通信将被IPv6路由系统自动丢弃；除非在前一个和下一个分布式定位之间建立一条临时的隧道用来维护到前一个本地前缀的可达性。依赖这些本地前缀的应用可能会遇到源IP地址变化的情况。</p>

<p>由eLMA2分配的RA消息携带的新的本地前缀（如图3.1中的PreC）目前有高优先级。MN将为PreC生成一个新的IPv6本地地址（图3.1中IP3）。</p>

<p>MN初始连接过程中eLMA1分配的全局前缀在RA消息中保持不变。为了维护这些全局地址的可达性，eLMA2应该向LMF执行位置更新，来维持全局前缀的可达性。<a href="http://tools.ietf.org/id/draft-luo-dmm-pmip-based-dmm-approach-01.txt">I-D.luo-dmm-pmip-based-dmm-approach</a>中的7.2节对切换细节进行了详细的描述。</p>

<p>因此，执行切换之后，既可以通过新的本地IPv6地址（如IP3）也可以通过全局IPv6地址（如IP2）来到达移动节点；如果在eLMA1和eLMA2之间有临时通道，也可以通过前一个本地IPv6地址（如IP1）到达。</p>

<p>是否在eLMA1与eLMA2之间建立临时隧道来维持本地前缀的可达，这取决于网络策略。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/05/06/draft-liu-dmm-dynamic-anchor-discussion-00/">Draft-liu-dmm-dynamic-anchor-discussion-00</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-05-06T10:40:00+08:00" pubdate data-updated="true">May 6<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>DMM Dynamic Anchor Discussion</h1>

<p><em>给MN配置多个地址</em></p>

<h3><a href="http://tools.ietf.org/html/draft-liu-dmm-dynamic-anchor-discussion-00">draft-liu-dmm-dynamic-anchor-discussion-00</a></h3>

<p>There are many different proposals for DMM solution, one of those types of solution is called &#8220;dynamic anchor&#8221;. This document analyses the limitations of current dynamic anchor solution and discusses the possible solution to overcome those limitations.</p>

<h2>Problem of dynamic anchor and potential solution</h2>

<blockquote><p>draft-seite-dmm-dma-00</p></blockquote>

<ol>
<li><p>The main idea of dynamic anchor is <strong>distributing the mobility anchor function in the access router (MAR)</strong>.</p></li>
<li><p><strong>The newly initiated session is routed through the current MAR</strong>, only the <strong>original sessions that established before handover will be maintained at the previous anchor</strong>.</p></li>
<li>picture</li>
</ol>


<h3>Active session managment</h3>

<blockquote><p>Problem: how MAR2 know that there is an active session for HNP1 in MN?</p>

<blockquote><p>policy server to store</p></blockquote>

<p>MAR2/MAR1 has to have some mechanism to trigger the release HNP1</p>

<blockquote><p>Otherwise MAR1 will always be occupied by the MN, this leads system capacity waste</p>

<p>One of possible solution is that MAR2 can inspect the traffic that has the source address prefix equals to HNP1.</p>

<p>Need many Timers on MAR2, which leads system capacity consumed</p></blockquote></blockquote>

<h3>Soure address selection</h3>

<blockquote><p>RFC3484 specifies the source address selection rules for IPv6 but RFC3484 is not enough to cope with this situation since RFC3284 does not specify how to select source address for a particular application.</p></blockquote>

<p><strong>Solution</strong></p>

<blockquote><p>For any on-going session, keep to use the original address even there is a newly address been configured for the same interface.</p>

<p>For any new session, always choose to use the newly allocated address. The new MAR need to advertise the newly allocated prefix as the highest priority.</p></blockquote>

<h3>CN address selection</h3>

<p>From the CN’s perspective, the MN has multiple addresses, the CN needs to know which one it should use when it wants to initiate a session to MN.</p>

<h3>IPv4 support</h3>

<p>It will worse the IPv4 address depletion problem if use the dynamic anchor solution for IPv4 since each MN will need multiple IP addresses in that case.</p>

<h3>Resource consumption consideration</h3>

<ul>
<li><p>MN在多个MAR间频繁切换，消耗网络资源</p></li>
<li><p>同时还有被hacker利用，消耗网络资源的危险</p></li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/05/06/draft-liu-dmm-address-selection-01/">Draft-liu-dmm-address-selection-01</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-05-06T10:35:00+08:00" pubdate data-updated="true">May 6<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>Address Selection for DMM</h1>

<h3><a href="http://tools.ietf.org/html/draft-liu-dmm-address-selection-01">draft-liu-dmm-address-selection-01</a></h3>

<pre><code>移动节点有可能有多个移动锚点以及相对应的前缀。
在这种情况下，移动节点需要知道地址类型以选择一个正确的地址供应用使用。
本篇文档描述了一种扩展路由通告消息的机制，通过携带一个标志以用来鉴别前缀的性质。
</code></pre>

<hr />

<h2>Problem of address selection for DMM</h2>

<blockquote><p>draft-liu-dmm-dynamic-anchor-discussion-00</p></blockquote>

<p>分布式移动管理动态节点方案有地址选择的问题。这个问题的难点在于：移动节点并不知道多个前缀之间的区别。网络无法告知移动节点不同前缀性质之间的区别，而且也没有标准的机制让移动节点选择正确的前缀。</p>

<h2>Extension to Router Advertisment</h2>

<p>   移动IPv6 <a href="http://www.ietf.org/rfc/rfc3775.txt">RFC3775</a> 扩展了IPv6路由通告消息用来移动探测和本地代理信息广播。这篇文档建议对IPv6路由通告消息进行更多扩展以携带一个标志对它通告的前缀性质进行鉴别。<strong>H位</strong>被用来标识路由通告是由本地代理发送的。</p>

<pre><code>                  +----------+---------+-------------------+
                  |  Type    |  Code   |     Checksum      |
                  +----------+-+-+-+---+-------------------+
                  |Hop Limit |M|O|H|Re-|    Router Lifetime|
                  +----------+-+-+-+---+-------------------+
                  |          Reachable Time                |
                  +----------------------------------------+
                  |          Retrans Timer                 |
                  +----------------------------------------+
                  |          Options                       |
                  +----------------------------------------+
</code></pre>

<p>扩展前缀消息选项，添加一个“T”标志，其定义如下：</p>

<h4>T类型标志</h4>

<ul>
<li>00: 本地网络前缀。它表明这个前缀是由该移动节点所属的路由器分配和通告的。</li>
<li>01: 远程网络前缀。它表明这个前缀是除这个移动节点所属的路由外的其他路由分配的。</li>
<li>10: 保留</li>
<li><p>11: 保留</p>

<pre><code>          +-------------+------------+------------+-+-+-+--+---+
          |    Type     |    Length  |PrefixLength|L|A|R|T |R- |
          +-------------+------------+------------+-+-+-+--+---+
          |                 Valid Lifetime                     |
          +----------------------------------------------------+
          |                 Preferred Lifetime                 |
          +----------------------------------------------------+
          |                 Reserved                           |
          +----------------------------------------------------+
          |                                                    |
          |                 Prefix                             |
          +----------------------------------------------------+
</code></pre></li>
</ul>


<p><strong>路由用来鉴别前缀类型的机制在这篇文档的范围之外。比如说，路由能通过查询策略服务器来知道由哪个路由分配特定的前缀。</strong></p>

<h2>Mobile Node Operation</h2>

<p>移动节点通过路由通告消息的T标志识别前缀类型。移动节点上的应用可以通过这个信息来选择正确的IP地址。比如说，在一个在会话中，应用一直选择之前使用的前缀直至其被移交到新的位置。对于新初始的应用，他会使用被当前路由分配的前缀。</p>

<h4>An Example of How This Draft Works</h4>

<pre><code>     _______     _______    _______
    |       |   |       |  |       |
    |  CN1  |   |  CN2  |  |  CN3  |
    |_______|   |_______|  |_______|
        '           .            .
 Flow#1 '    Flow#2 .            |  Flow#3
        '   ...'''''.'''''''.... .
      ..'''         .           '''..
    .'  '      IP network        .   '.
    :   '           .            |    :
     '..'       +-------+        . ..'
        '''...  |       |.......'''
        '       | MAR2  | \      .
        '       |       |. \     |
        '       |       | . \    .
        '       +-------+\  .\   |
   +-------+   HNP2(T=00) \  + ------+
   |       |   HNP1(T=01)  \ |       | HNP3(T=00)
   | MAR1  |-----------------|  MAR3 | HNP2(T=01)
   |       | ''''''''''''''''|       | HNP1(T=01)
   |       |-----------------|       |
   +-------+                 +-------+
   HNP1(T=00)                   ' . |
                        Flow#1  ' . .  Flow#3
                                ' . |
     +-----+            Flow#2 +-----+
     | MN  | -----move-------&gt; | MN  |
     +-----+                   +-----+
</code></pre>

<ol>
<li>当移动节点附属到MAR1，MAR1发送了路由通告消息，包含前缀信息选项的移动节点的HNP1以及T标志位设置为00。这表明HNP1是由当前路由（MAR1）分配和通告的本地网络前缀。移动节点能通过取自HNP1的IPv6地址初始化与CN1的会话（如图中的flow#1）。</li>
<li>当移动节点切换至MAR2（flow#1在移动节点切换时仍在持续），MAR2发送包含了移动节点的HNP2的路由通告消息，其类型标志T被设置成00，同时之前的前缀（HNP1）被设置成01。移动节点就会识别HNP2是当前本地网络前缀，而HNP1是远程网络前缀。这时，移动节点会用取自HNP2的IPv6地址作为源地址初始化一个新的与CN2（如图中的flow#2）会话。因为IPv6地址取自本地网络前缀（HNP2），flow#2会使用常规的IPv6协议。对于flow#1，MAR1充当LMA，MAR2充当MAG。</li>
<li>当移动节点切换至MAR3时（移动节点切换时flow#1和flow#2仍在持续），MAR3发送包含了移动节点新的前缀（HNP3）的路由通告消息，类型标志（T）被置为00，而之前的前缀（HNP1、HNP2）的类型标志（T）被置为01。这表明HNP3是本地网络前缀，而HNP1和HNP2是远程网络前缀。这时，移动节点把从HNP3取得的IPv6地址作为原地址，初始化与CN3的会话（比如图中的flow#3）。flow#3使用常规的IPv6协议。</li>
</ol>


<h4>MN Handoffs From MAR Back to Its Previous MAR</h4>

<p>上述过程的逆过程。略。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/05/06/draft-korhonen-dmm-prefix-properties-03/">Draft-korhonen-dmm-prefix-properties-03</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-05-06T10:29:00+08:00" pubdate data-updated="true">May 6<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>IPv6 Prefix Mobility Management Properties</h1>

<h3><a href="http://tools.ietf.org/html/draft-korhonen-dmm-prefix-properties-03">draft-korhonen-dmm-prefix-properties-03.txt</a></h3>

<pre><code>这篇规范定义并扩展IPv6邻居发现协议的前缀信息选项，扩展其标志位来描述与前缀相关的移动管理性质。
这篇draft更新了[RFC4861](http://tools.ietf.org/rfc/rfc4861.txt)。
</code></pre>

<hr />

<h2>Background and Motivation</h2>

<ul>
<li>非最优路由</li>
<li>过多的隧道，为了维护移动性相关绑定而增加的信令</li>
<li>集中式的MAG下流量聚合</li>
</ul>


<p>In general, it is observed that most applications do not need IP level mobility, and work just
fine with &#8220;temporary&#8221; IP addresses that come and go. However, IP mobility still has its virtues making the applications unaware of mobility, and certain wireless mobile networking architecture make extensive use of network based IP mobility.</p>

<p>在许多情况下，这可能会导致MN有多个地址被使用，但是其中一些提供了移动性，而另一些没有提供。不得不提供方法来让终端主机区分是否是提供了移动性的地址，还是一些生存期很短并且只能在一个受限的拓扑域使用的地址。</p>

<p><strong>这篇draft提供了IPv6地址管理的扩展以及源地址的选择，这样终端主机（以及它的应用）就能够为它们的需求选择一个合适的地址。</strong></p>

<h2>Option Formats</h2>

<pre><code>'M' 长为1位的标志，描述了前缀的移动性，其性质被定义为：
0 这个前缀没有相关的基于网络的移动性，这个前缀以RFC4861中所提供的方式进行处理。
1 这个前缀提供了基于网络的移动性并且可能保持前缀未改变的有效时间。


'S' 长为1位的标志，它能够提供与使用前缀相关的安全性质的提示。

'Class' 长达14位的前缀分类，这个前缀分类加上了移动性与安全性的补充信息。0被保留，该值没有描述前缀的任何信息。对于未知的分类都将其值置为0。

我们将'M'位、'S'位以及'class’的结合称之为前缀性质。
</code></pre>

<h2>Host Considerations</h2>

<blockquote><p>[I-D.liu-dmm-mobility-api]</p></blockquote>

<h4>内部数据结构</h4>

<p>主机内部数据结构需要被前缀性质信息扩展，这些信息与已学习的前缀及配置地址相关联。关于这一点是如何完成是需要由具体的主机来指定的。一个应用怎样才能够知道或询问到一个地址或一个前缀的移动性也是由具体主机的实现来决定的。一个可能性是通过socket API的扩展来提供这样的信息。（关于这点可以看 <a href="http://tools.ietf.org/id/draft-korhonen-dmm-prefix-properties-03.txt">I-D.liu-dmm-mobility-api</a> 中的讨论）。其它的可能性包括ioctl（）的扩展以及NetLink的扩展。</p>

<h4>默认地址选择</h4>

<p>“前缀性质”提供的信息只能用来作为一种提示。它并不会自动的影响已经存在了的东西<a href="http://tools.ietf.org/rfc/rfc6724.txt">RFC6724</a>，除了稍后将要描述的&#8217;M&#8217;标志位之外。对于主机的策略表来说，一个详细的规则不得不被一个应用或者一些守护进程插入。在可选情况下，一个应用能够通过在<a href="http://tools.ietf.org/id/draft-korhonen-dmm-prefix-properties-03.txt">I-D.liu-dmm-mobility-api</a>中讨论的socket API的扩展来表达地址移动性的优先级，这就意味着库文件或中间件不得不修改策略表或算法。</p>

<blockquote><p>The ’M’ flag defines the prefix preference for an IP stack that
understands the extensions defined in this specification. The IP
stack SHOULD use the following preferences to supersede [RFC6724]
Source Address Selection Rule 8 when selecting a default source
address among multiple choices and an application has not explicitly
indicate what kind of source address it prefers:</p>

<ul>
<li><p>0 Default preference.</p></li>
<li><p>1 Low preference.</p></li>
</ul>
</blockquote>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/2/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2013/05/20/ruby-functional-programming/">Ruby 函数式编程</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/05/06/set-local-octopress-env/">为已托管在github的octopress配置本地环境</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/05/06/draft-mccann-dmm-flatarch-00/">draft-mccann-dmm-flatarch-00</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/05/06/draft-ma-dmm-romip-00/">draft-ma-dmm-romip-00</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/05/06/draft-ma-dmm-armip-00/">draft-ma-dmm-armip-00</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - Peng Feixiang -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
